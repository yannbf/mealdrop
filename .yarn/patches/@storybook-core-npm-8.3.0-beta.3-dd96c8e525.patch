diff --git a/dist/csf-tools/index.cjs b/dist/csf-tools/index.cjs
index b5410ed861e545994ee03a9d68f81d7d92582865..b1dc452280bfe5d322dee1b5b6ce12aa60b5c6c9 100644
--- a/dist/csf-tools/index.cjs
+++ b/dist/csf-tools/index.cjs
@@ -1,201 +1,271 @@
 "use strict";
-var Me = Object.create;
-var w = Object.defineProperty;
-var $e = Object.getOwnPropertyDescriptor;
-var Ue = Object.getOwnPropertyNames;
-var qe = Object.getPrototypeOf, Be = Object.prototype.hasOwnProperty;
-var p = (s, e) => w(s, "name", { value: e, configurable: !0 });
-var We = (s, e) => () => (e || s((e = { exports: {} }).exports, e), e.exports), ze = (s, e) => {
-  for (var i in e)
-    w(s, i, { get: e[i], enumerable: !0 });
-}, ie = (s, e, i, t) => {
-  if (e && typeof e == "object" || typeof e == "function")
-    for (let r of Ue(e))
-      !Be.call(s, r) && r !== i && w(s, r, { get: () => e[r], enumerable: !(t = $e(e, r)) || t.enumerable });
-  return s;
+var __create = Object.create;
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __getOwnPropNames = Object.getOwnPropertyNames;
+var __getProtoOf = Object.getPrototypeOf;
+var __hasOwnProp = Object.prototype.hasOwnProperty;
+var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
+var __commonJS = (cb, mod) => function __require() {
+  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
 };
-var M = (s, e, i) => (i = s != null ? Me(qe(s)) : {}, ie(
+var __export = (target, all) => {
+  for (var name in all)
+    __defProp(target, name, { get: all[name], enumerable: true });
+};
+var __copyProps = (to, from, except, desc) => {
+  if (from && typeof from === "object" || typeof from === "function") {
+    for (let key of __getOwnPropNames(from))
+      if (!__hasOwnProp.call(to, key) && key !== except)
+        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+  }
+  return to;
+};
+var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
   // If the importer is in node compatibility mode or this is not an ESM
   // file that has been converted to a CommonJS file using a Babel-
   // compatible transform (i.e. "__esModule" has not been set), then set
   // "default" to the CommonJS "module.exports" for node compatibility.
-  e || !s || !s.__esModule ? w(i, "default", { value: s, enumerable: !0 }) : i,
-  s
-)), Ge = (s) => ie(w({}, "__esModule", { value: !0 }), s);
+  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
+  mod
+));
+var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
 
 // ../node_modules/ts-dedent/dist/index.js
-var C = We((F) => {
-  "use strict";
-  Object.defineProperty(F, "__esModule", { value: !0 });
-  F.dedent = void 0;
-  function se(s) {
-    for (var e = [], i = 1; i < arguments.length; i++)
-      e[i - 1] = arguments[i];
-    var t = Array.from(typeof s == "string" ? [s] : s);
-    t[t.length - 1] = t[t.length - 1].replace(/\r?\n([\t ]*)$/, "");
-    var r = t.reduce(function(l, u) {
-      var d = u.match(/\n([\t ]+|(?!\s).)/g);
-      return d ? l.concat(d.map(function(x) {
-        var g, b;
-        return (b = (g = x.match(/[\t ]/g)) === null || g === void 0 ? void 0 : g.length) !== null && b !== void 0 ? b : 0;
-      })) : l;
-    }, []);
-    if (r.length) {
-      var a = new RegExp(`
-[	 ]{` + Math.min.apply(Math, r) + "}", "g");
-      t = t.map(function(l) {
-        return l.replace(a, `
-`);
+var require_dist = __commonJS({
+  "../node_modules/ts-dedent/dist/index.js"(exports) {
+    "use strict";
+    Object.defineProperty(exports, "__esModule", { value: true });
+    exports.dedent = void 0;
+    function dedent5(templ) {
+      var values = [];
+      for (var _i = 1; _i < arguments.length; _i++) {
+        values[_i - 1] = arguments[_i];
+      }
+      var strings = Array.from(typeof templ === "string" ? [templ] : templ);
+      strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
+      var indentLengths = strings.reduce(function(arr, str) {
+        var matches = str.match(/\n([\t ]+|(?!\s).)/g);
+        if (matches) {
+          return arr.concat(matches.map(function(match) {
+            var _a, _b;
+            return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
+          }));
+        }
+        return arr;
+      }, []);
+      if (indentLengths.length) {
+        var pattern_1 = new RegExp("\n[	 ]{" + Math.min.apply(Math, indentLengths) + "}", "g");
+        strings = strings.map(function(str) {
+          return str.replace(pattern_1, "\n");
+        });
+      }
+      strings[0] = strings[0].replace(/^\r?\n/, "");
+      var string = strings[0];
+      values.forEach(function(value, i) {
+        var endentations = string.match(/(?:^|\n)( *)$/);
+        var endentation = endentations ? endentations[1] : "";
+        var indentedValue = value;
+        if (typeof value === "string" && value.includes("\n")) {
+          indentedValue = String(value).split("\n").map(function(str, i2) {
+            return i2 === 0 ? str : "" + endentation + str;
+          }).join("\n");
+        }
+        string += indentedValue + strings[i + 1];
       });
+      return string;
     }
-    t[0] = t[0].replace(/^\r?\n/, "");
-    var n = t[0];
-    return e.forEach(function(l, u) {
-      var d = n.match(/(?:^|\n)( *)$/), x = d ? d[1] : "", g = l;
-      typeof l == "string" && l.includes(`
-`) && (g = String(l).split(`
-`).map(function(b, h) {
-        return h === 0 ? b : "" + x + b;
-      }).join(`
-`)), n += g + t[u + 1];
-    }), n;
-  }
-  p(se, "dedent");
-  F.dedent = se;
-  F.default = se;
+    __name(dedent5, "dedent");
+    exports.dedent = dedent5;
+    exports.default = dedent5;
+  }
 });
 
 // src/csf-tools/index.ts
-var ot = {};
-ze(ot, {
-  ConfigFile: () => W,
-  CsfFile: () => $,
-  NoMetaError: () => k,
-  babelParse: () => Ne.babelParse,
-  babelParseFile: () => pe,
-  enrichCsf: () => st,
-  enrichCsfMeta: () => je,
-  enrichCsfStory: () => _e,
-  extractDescription: () => Z,
-  extractSource: () => Oe,
-  formatConfig: () => ye,
-  formatCsf: () => J,
-  getStorySortParameter: () => it,
-  isModuleMock: () => ce,
-  loadConfig: () => xe,
-  loadCsf: () => q,
-  printConfig: () => be,
-  printCsf: () => fe,
-  readConfig: () => Ze,
-  readCsf: () => He,
-  vitestTransform: () => Ie,
-  writeConfig: () => et,
-  writeCsf: () => Ye
+var csf_tools_exports = {};
+__export(csf_tools_exports, {
+  ConfigFile: () => ConfigFile,
+  CsfFile: () => CsfFile,
+  NoMetaError: () => NoMetaError,
+  babelParse: () => import_babel7.babelParse,
+  babelParseFile: () => babelParseFile,
+  enrichCsf: () => enrichCsf,
+  enrichCsfMeta: () => enrichCsfMeta,
+  enrichCsfStory: () => enrichCsfStory,
+  extractDescription: () => extractDescription,
+  extractSource: () => extractSource,
+  formatConfig: () => formatConfig,
+  formatCsf: () => formatCsf,
+  getStorySortParameter: () => getStorySortParameter,
+  isModuleMock: () => isModuleMock,
+  loadConfig: () => loadConfig,
+  loadCsf: () => loadCsf,
+  printConfig: () => printConfig,
+  printCsf: () => printCsf,
+  readConfig: () => readConfig,
+  readCsf: () => readCsf,
+  vitestTransform: () => vitestTransform,
+  writeConfig: () => writeConfig,
+  writeCsf: () => writeCsf
 });
-module.exports = Ge(ot);
+module.exports = __toCommonJS(csf_tools_exports);
 
 // src/csf-tools/CsfFile.ts
-var U = require("node:fs/promises"), c = require("@storybook/core/babel"), P = require("@storybook/csf"), T = M(C(), 1);
+var import_promises = require("node:fs/promises");
+var import_babel2 = require("@storybook/core/babel");
+var import_csf = require("@storybook/csf");
+var import_ts_dedent = __toESM(require_dist(), 1);
 
 // src/csf-tools/findVarInitialization.ts
-var v = require("@storybook/core/babel");
-var O = /* @__PURE__ */ p((s, e) => {
-  let i = null, t = null;
-  return e.body.find((r) => (v.types.isVariableDeclaration(r) ? t = r.declarations : v.types.isExportNamedDeclaration(r) && v.types.isVariableDeclaration(
-  r.declaration) && (t = r.declaration.declarations), t && t.find((a) => v.types.isVariableDeclarator(a) && v.types.isIdentifier(a.id) && a.
-  id.name === s ? (i = a.init, !0) : !1))), i;
+var import_babel = require("@storybook/core/babel");
+var findVarInitialization = /* @__PURE__ */ __name((identifier, program) => {
+  let init = null;
+  let declarations = null;
+  program.body.find((node) => {
+    if (import_babel.types.isVariableDeclaration(node)) {
+      declarations = node.declarations;
+    } else if (import_babel.types.isExportNamedDeclaration(node) && import_babel.types.isVariableDeclaration(node.declaration)) {
+      declarations = node.declaration.declarations;
+    }
+    return declarations && declarations.find((decl) => {
+      if (import_babel.types.isVariableDeclarator(decl) && import_babel.types.isIdentifier(decl.id) && decl.id.name === identifier) {
+        init = decl.init;
+        return true;
+      }
+      return false;
+    });
+  });
+  return init;
 }, "findVarInitialization");
 
 // src/csf-tools/CsfFile.ts
-var ne = console;
-function Je(s) {
-  if (c.types.isArrayExpression(s))
-    return s.elements.map((e) => {
-      if (c.types.isStringLiteral(e))
+var logger = console;
+function parseIncludeExclude(prop) {
+  if (import_babel2.types.isArrayExpression(prop)) {
+    return prop.elements.map((e) => {
+      if (import_babel2.types.isStringLiteral(e)) {
         return e.value;
+      }
       throw new Error(`Expected string literal: ${e}`);
     });
-  if (c.types.isStringLiteral(s))
-    return new RegExp(s.value);
-  if (c.types.isRegExpLiteral(s))
-    return new RegExp(s.pattern, s.flags);
-  throw new Error(`Unknown include/exclude: ${s}`);
+  }
+  if (import_babel2.types.isStringLiteral(prop)) {
+    return new RegExp(prop.value);
+  }
+  if (import_babel2.types.isRegExpLiteral(prop)) {
+    return new RegExp(prop.pattern, prop.flags);
+  }
+  throw new Error(`Unknown include/exclude: ${prop}`);
 }
-p(Je, "parseIncludeExclude");
-function oe(s) {
-  if (!c.types.isArrayExpression(s))
+__name(parseIncludeExclude, "parseIncludeExclude");
+function parseTags(prop) {
+  if (!import_babel2.types.isArrayExpression(prop)) {
     throw new Error("CSF: Expected tags array");
-  return s.elements.map((e) => {
-    if (c.types.isStringLiteral(e))
+  }
+  return prop.elements.map((e) => {
+    if (import_babel2.types.isStringLiteral(e)) {
       return e.value;
-    throw new Error("CSF: Expected tag to be string literal");
+    }
+    throw new Error(`CSF: Expected tag to be string literal`);
   });
 }
-p(oe, "parseTags");
-var G = /* @__PURE__ */ p((s, e) => {
-  let { line: i, column: t } = s.loc?.start || {};
-  return `${e || ""} (line ${i}, col ${t})`.trim();
-}, "formatLocation"), ce = /* @__PURE__ */ p((s) => Qe.test(s), "isModuleMock"), ae = /* @__PURE__ */ p((s, e, i) => {
-  let t = s;
-  if (c.types.isCallExpression(s)) {
-    let { callee: r, arguments: a } = s;
-    if (c.types.isProgram(e) && c.types.isMemberExpression(r) && c.types.isIdentifier(r.object) && c.types.isIdentifier(r.property) && r.property.
-    name === "bind" && (a.length === 0 || a.length === 1 && c.types.isObjectExpression(a[0]) && a[0].properties.length === 0)) {
-      let n = r.object.name, l = O(n, e);
-      l && (i._templates[n] = l, t = l);
+__name(parseTags, "parseTags");
+var formatLocation = /* @__PURE__ */ __name((node, fileName) => {
+  const { line, column } = node.loc?.start || {};
+  return `${fileName || ""} (line ${line}, col ${column})`.trim();
+}, "formatLocation");
+var isModuleMock = /* @__PURE__ */ __name((importPath) => MODULE_MOCK_REGEX.test(importPath), "isModuleMock");
+var isArgsStory = /* @__PURE__ */ __name((init, parent, csf) => {
+  let storyFn = init;
+  if (import_babel2.types.isCallExpression(init)) {
+    const { callee, arguments: bindArguments } = init;
+    if (import_babel2.types.isProgram(parent) && import_babel2.types.isMemberExpression(callee) && import_babel2.types.isIdentifier(callee.object) &&
+    import_babel2.types.isIdentifier(callee.property) && callee.property.name === "bind" && (bindArguments.length === 0 || bindArguments.length ===
+    1 && import_babel2.types.isObjectExpression(bindArguments[0]) && bindArguments[0].properties.length === 0)) {
+      const boundIdentifier = callee.object.name;
+      const template = findVarInitialization(boundIdentifier, parent);
+      if (template) {
+        csf._templates[boundIdentifier] = template;
+        storyFn = template;
+      }
     }
   }
-  return c.types.isArrowFunctionExpression(t) || c.types.isFunctionDeclaration(t) ? t.params.length > 0 : !1;
-}, "isArgsStory"), Ke = /* @__PURE__ */ p((s) => {
-  if (c.types.isArrayExpression(s))
-    return s.elements.map((e) => {
-      if (c.types.isStringLiteral(e))
-        return e.value;
-      throw new Error(`Expected string literal named export: ${e}`);
+  if (import_babel2.types.isArrowFunctionExpression(storyFn)) {
+    return storyFn.params.length > 0;
+  }
+  if (import_babel2.types.isFunctionDeclaration(storyFn)) {
+    return storyFn.params.length > 0;
+  }
+  return false;
+}, "isArgsStory");
+var parseExportsOrder = /* @__PURE__ */ __name((init) => {
+  if (import_babel2.types.isArrayExpression(init)) {
+    return init.elements.map((item) => {
+      if (import_babel2.types.isStringLiteral(item)) {
+        return item.value;
+      }
+      throw new Error(`Expected string literal named export: ${item}`);
     });
-  throw new Error(`Expected array of string literals: ${s}`);
-}, "parseExportsOrder"), le = /* @__PURE__ */ p((s, e) => e.reduce(
-  (i, t) => {
-    let r = s[t];
-    return r && (i[t] = r), i;
-  },
-  {}
-), "sortExports"), Xe = /* @__PURE__ */ p((s) => {
-  if (c.types.isArrowFunctionExpression(s) || c.types.isFunctionDeclaration(s)) {
-    let e = s.params;
-    if (e.length >= 1) {
-      let [i] = e;
-      if (c.types.isObjectPattern(i))
-        return !!i.properties.find((t) => {
-          if (c.types.isObjectProperty(t) && c.types.isIdentifier(t.key))
-            return t.key.name === "mount";
+  }
+  throw new Error(`Expected array of string literals: ${init}`);
+}, "parseExportsOrder");
+var sortExports = /* @__PURE__ */ __name((exportByName, order) => {
+  return order.reduce(
+    (acc, name) => {
+      const namedExport = exportByName[name];
+      if (namedExport) {
+        acc[name] = namedExport;
+      }
+      return acc;
+    },
+    {}
+  );
+}, "sortExports");
+var hasMount = /* @__PURE__ */ __name((play) => {
+  if (import_babel2.types.isArrowFunctionExpression(play) || import_babel2.types.isFunctionDeclaration(play)) {
+    const params = play.params;
+    if (params.length >= 1) {
+      const [arg] = params;
+      if (import_babel2.types.isObjectPattern(arg)) {
+        return !!arg.properties.find((prop) => {
+          if (import_babel2.types.isObjectProperty(prop) && import_babel2.types.isIdentifier(prop.key)) {
+            return prop.key.name === "mount";
+          }
         });
+      }
     }
   }
-  return !1;
-}, "hasMount"), Qe = /^[.\/#].*\.mock($|\.[^.]*$)/i, k = class extends Error {
+  return false;
+}, "hasMount");
+var MODULE_MOCK_REGEX = /^[.\/#].*\.mock($|\.[^.]*$)/i;
+var NoMetaError = class extends Error {
   static {
-    p(this, "NoMetaError");
+    __name(this, "NoMetaError");
   }
-  constructor(e, i, t) {
-    super(T.dedent`
-      CSF: ${e} ${G(i, t)}
+  constructor(message, ast, fileName) {
+    super(import_ts_dedent.dedent`
+      CSF: ${message} ${formatLocation(ast, fileName)}
 
       More info: https://storybook.js.org/docs/react/writing-stories#default-export
-    `), this.name = this.constructor.name;
+    `);
+    this.name = this.constructor.name;
   }
-}, $ = class {
-  constructor(e, i, t) {
+};
+var CsfFile = class {
+  constructor(ast, options, file) {
     this._stories = {};
     this._metaAnnotations = {};
     this._storyExports = {};
     this._storyStatements = {};
     this._storyAnnotations = {};
     this._templates = {};
-    this._ast = e, this._file = t, this._options = i, this.imports = [];
+    this._ast = ast;
+    this._file = file;
+    this._options = options;
+    this.imports = [];
   }
   static {
-    p(this, "CsfFile");
+    __name(this, "CsfFile");
   }
   /** @deprecated Use `_options.fileName` instead */
   get _fileName() {
@@ -205,246 +275,353 @@ var G = /* @__PURE__ */ p((s, e) => {
   get _makeTitle() {
     return this._options.makeTitle;
   }
-  _parseTitle(e) {
-    let i = c.types.isIdentifier(e) ? O(e.name, this._ast.program) : e;
-    if (c.types.isStringLiteral(i))
-      return i.value;
-    if (c.types.isTSSatisfiesExpression(i) && c.types.isStringLiteral(i.expression))
-      return i.expression.value;
-    throw new Error(T.dedent`
-      CSF: unexpected dynamic title ${G(i, this._options.fileName)}
+  _parseTitle(value) {
+    const node = import_babel2.types.isIdentifier(value) ? findVarInitialization(value.name, this._ast.program) : value;
+    if (import_babel2.types.isStringLiteral(node)) {
+      return node.value;
+    }
+    if (import_babel2.types.isTSSatisfiesExpression(node) && import_babel2.types.isStringLiteral(node.expression)) {
+      return node.expression.value;
+    }
+    throw new Error(import_ts_dedent.dedent`
+      CSF: unexpected dynamic title ${formatLocation(node, this._options.fileName)}
 
       More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#string-literal-titles
     `);
   }
-  _parseMeta(e, i) {
-    let t = {};
-    e.properties.forEach((r) => {
-      if (c.types.isIdentifier(r.key)) {
-        if (this._metaAnnotations[r.key.name] = r.value, r.key.name === "title")
-          t.title = this._parseTitle(r.value);
-        else if (["includeStories", "excludeStories"].includes(r.key.name))
-          t[r.key.name] = Je(r.value);
-        else if (r.key.name === "component") {
-          let a = r.value;
-          if (c.types.isIdentifier(a)) {
-            let l = a.name, u = i.body.find(
-              (d) => c.types.isImportDeclaration(d) && d.specifiers.find((x) => x.local.name === l)
+  _parseMeta(declaration, program) {
+    const meta = {};
+    declaration.properties.forEach((p) => {
+      if (import_babel2.types.isIdentifier(p.key)) {
+        this._metaAnnotations[p.key.name] = p.value;
+        if (p.key.name === "title") {
+          meta.title = this._parseTitle(p.value);
+        } else if (["includeStories", "excludeStories"].includes(p.key.name)) {
+          meta[p.key.name] = parseIncludeExclude(p.value);
+        } else if (p.key.name === "component") {
+          const n = p.value;
+          if (import_babel2.types.isIdentifier(n)) {
+            const id = n.name;
+            const importStmt = program.body.find(
+              (stmt) => import_babel2.types.isImportDeclaration(stmt) && stmt.specifiers.find((spec) => spec.local.name === id)
             );
-            if (u) {
-              let { source: d } = u;
-              c.types.isStringLiteral(d) && (this._rawComponentPath = d.value);
+            if (importStmt) {
+              const { source } = importStmt;
+              if (import_babel2.types.isStringLiteral(source)) {
+                this._rawComponentPath = source.value;
+              }
             }
           }
-          let { code: n } = c.recast.print(r.value, {});
-          t.component = n;
-        } else if (r.key.name === "tags") {
-          let a = r.value;
-          c.types.isIdentifier(a) && (a = O(a.name, this._ast.program)), t.tags = oe(a);
-        } else if (r.key.name === "id")
-          if (c.types.isStringLiteral(r.value))
-            t.id = r.value.value;
-          else
-            throw new Error(`Unexpected component id: ${r.value}`);
+          const { code } = import_babel2.recast.print(p.value, {});
+          meta.component = code;
+        } else if (p.key.name === "tags") {
+          let node = p.value;
+          if (import_babel2.types.isIdentifier(node)) {
+            node = findVarInitialization(node.name, this._ast.program);
+          }
+          meta.tags = parseTags(node);
+        } else if (p.key.name === "id") {
+          if (import_babel2.types.isStringLiteral(p.value)) {
+            meta.id = p.value.value;
+          } else {
+            throw new Error(`Unexpected component id: ${p.value}`);
+          }
+        }
       }
-    }), this._meta = t;
-  }
-  getStoryExport(e) {
-    let i = this._storyExports[e];
-    if (i = c.types.isVariableDeclarator(i) ? i.init : i, c.types.isCallExpression(i)) {
-      let { callee: t, arguments: r } = i;
-      if (c.types.isMemberExpression(t) && c.types.isIdentifier(t.object) && c.types.isIdentifier(t.property) && t.property.name === "bind" &&
-      (r.length === 0 || r.length === 1 && c.types.isObjectExpression(r[0]) && r[0].properties.length === 0)) {
-        let { name: a } = t.object;
-        i = this._templates[a];
+    });
+    this._meta = meta;
+  }
+  getStoryExport(key) {
+    let node = this._storyExports[key];
+    node = import_babel2.types.isVariableDeclarator(node) ? node.init : node;
+    if (import_babel2.types.isCallExpression(node)) {
+      const { callee, arguments: bindArguments } = node;
+      if (import_babel2.types.isMemberExpression(callee) && import_babel2.types.isIdentifier(callee.object) && import_babel2.types.isIdentifier(
+      callee.property) && callee.property.name === "bind" && (bindArguments.length === 0 || bindArguments.length === 1 && import_babel2.types.
+      isObjectExpression(bindArguments[0]) && bindArguments[0].properties.length === 0)) {
+        const { name } = callee.object;
+        node = this._templates[name];
       }
     }
-    return i;
+    return node;
   }
   parse() {
-    let e = this;
-    if ((0, c.traverse)(this._ast, {
+    const self = this;
+    (0, import_babel2.traverse)(this._ast, {
       ExportDefaultDeclaration: {
-        enter(t) {
-          let { node: r, parent: a } = t, n = c.types.isIdentifier(r.declaration) && c.types.isProgram(a);
-          if (e._options.transformInlineMeta && !n && c.types.isExpression(r.declaration)) {
-            let d = t.scope.generateUidIdentifier("meta");
-            e._metaVariableName = d.name;
-            let x = [
-              c.types.variableDeclaration("const", [c.types.variableDeclarator(d, r.declaration)]),
-              c.types.exportDefaultDeclaration(d)
+        enter(path) {
+          const { node, parent } = path;
+          const isVariableReference = import_babel2.types.isIdentifier(node.declaration) && import_babel2.types.isProgram(parent);
+          if (self._options.transformInlineMeta && !isVariableReference && import_babel2.types.isExpression(node.declaration)) {
+            const metaId = path.scope.generateUidIdentifier("meta");
+            self._metaVariableName = metaId.name;
+            const nodes = [
+              import_babel2.types.variableDeclaration("const", [import_babel2.types.variableDeclarator(metaId, node.declaration)]),
+              import_babel2.types.exportDefaultDeclaration(metaId)
             ];
-            x.forEach((g) => g.loc = t.node.loc), t.replaceWithMultiple(x);
+            nodes.forEach((_node) => _node.loc = path.node.loc);
+            path.replaceWithMultiple(nodes);
           }
-          let l, u;
-          if (n) {
-            let d = r.declaration.name;
-            e._metaVariableName = d;
-            let x = /* @__PURE__ */ p((g) => c.types.isIdentifier(g.id) && g.id.name === d, "isVariableDeclarator");
-            e._metaStatement = e._ast.program.body.find(
-              (g) => c.types.isVariableDeclaration(g) && g.declarations.find(x)
-            ), u = (e?._metaStatement?.declarations || []).find(
-              x
+          let metaNode;
+          let decl;
+          if (isVariableReference) {
+            const variableName = node.declaration.name;
+            self._metaVariableName = variableName;
+            const isVariableDeclarator = /* @__PURE__ */ __name((declaration) => import_babel2.types.isIdentifier(declaration.id) && declaration.
+            id.name === variableName, "isVariableDeclarator");
+            self._metaStatement = self._ast.program.body.find(
+              (topLevelNode) => import_babel2.types.isVariableDeclaration(topLevelNode) && topLevelNode.declarations.find(isVariableDeclarator)
+            );
+            decl = (self?._metaStatement?.declarations || []).find(
+              isVariableDeclarator
             )?.init;
-          } else
-            e._metaStatement = r, u = r.declaration;
-          if (c.types.isObjectExpression(u) ? l = u : (
+          } else {
+            self._metaStatement = node;
+            decl = node.declaration;
+          }
+          if (import_babel2.types.isObjectExpression(decl)) {
+            metaNode = decl;
+          } else if (
             // export default { ... } as Meta<...>
-            (c.types.isTSAsExpression(u) || c.types.isTSSatisfiesExpression(u)) && c.types.isObjectExpression(u.expression) && (l = u.expression)
-          ), !e._meta && l && c.types.isProgram(a) && (e._metaNode = l, e._parseMeta(l, a)), e._metaStatement && !e._metaNode)
-            throw new k(
+            (import_babel2.types.isTSAsExpression(decl) || import_babel2.types.isTSSatisfiesExpression(decl)) && import_babel2.types.isObjectExpression(
+            decl.expression)
+          ) {
+            metaNode = decl.expression;
+          }
+          if (!self._meta && metaNode && import_babel2.types.isProgram(parent)) {
+            self._metaNode = metaNode;
+            self._parseMeta(metaNode, parent);
+          }
+          if (self._metaStatement && !self._metaNode) {
+            throw new NoMetaError(
               "default export must be an object",
-              e._metaStatement,
-              e._options.fileName
+              self._metaStatement,
+              self._options.fileName
             );
+          }
         }
       },
       ExportNamedDeclaration: {
-        enter({ node: t, parent: r }) {
-          let a;
-          c.types.isVariableDeclaration(t.declaration) ? a = t.declaration.declarations.filter((n) => c.types.isVariableDeclarator(n)) : c.types.
-          isFunctionDeclaration(t.declaration) && (a = [t.declaration]), a ? a.forEach((n) => {
-            if (c.types.isIdentifier(n.id)) {
-              let { name: l } = n.id;
-              if (l === "__namedExportsOrder" && c.types.isVariableDeclarator(n)) {
-                e._namedExportsOrder = Ke(n.init);
-                return;
-              }
-              e._storyExports[l] = n, e._storyStatements[l] = t;
-              let u = (0, P.storyNameFromExport)(l);
-              e._storyAnnotations[l] ? ne.warn(
-                `Unexpected annotations for "${l}" before story declaration`
-              ) : e._storyAnnotations[l] = {};
-              let d;
-              c.types.isVariableDeclarator(n) ? d = c.types.isTSAsExpression(n.init) || c.types.isTSSatisfiesExpression(n.init) ? n.init.expression :
-              n.init : d = n;
-              let x = {};
-              c.types.isObjectExpression(d) ? (x.__isArgsStory = !0, d.properties.forEach((g) => {
-                if (c.types.isIdentifier(g.key)) {
-                  if (g.key.name === "render")
-                    x.__isArgsStory = ae(
-                      g.value,
-                      r,
-                      e
-                    );
-                  else if (g.key.name === "name" && c.types.isStringLiteral(g.value))
-                    u = g.value.value;
-                  else if (g.key.name === "storyName" && c.types.isStringLiteral(g.value))
-                    ne.warn(
-                      `Unexpected usage of "storyName" in "${l}". Please use "name" instead.`
-                    );
-                  else if (g.key.name === "parameters" && c.types.isObjectExpression(g.value)) {
-                    let b = g.value.properties.find(
-                      (h) => c.types.isObjectProperty(h) && c.types.isIdentifier(h.key) && h.key.name === "__id"
-                    );
-                    b && (x.__id = b.value.value);
-                  }
-                  e._storyAnnotations[l][g.key.name] = g.value;
+        enter({ node, parent }) {
+          let declarations;
+          if (import_babel2.types.isVariableDeclaration(node.declaration)) {
+            declarations = node.declaration.declarations.filter((d) => import_babel2.types.isVariableDeclarator(d));
+          } else if (import_babel2.types.isFunctionDeclaration(node.declaration)) {
+            declarations = [node.declaration];
+          }
+          if (declarations) {
+            declarations.forEach((decl) => {
+              if (import_babel2.types.isIdentifier(decl.id)) {
+                const { name: exportName } = decl.id;
+                if (exportName === "__namedExportsOrder" && import_babel2.types.isVariableDeclarator(decl)) {
+                  self._namedExportsOrder = parseExportsOrder(decl.init);
+                  return;
                 }
-              })) : x.__isArgsStory = ae(d, r, e), e._stories[l] = {
-                id: "FIXME",
-                name: u,
-                parameters: x,
-                __stats: {}
-              };
-            }
-          }) : t.specifiers.length > 0 && t.specifiers.forEach((n) => {
-            if (c.types.isExportSpecifier(n) && c.types.isIdentifier(n.exported)) {
-              let { name: l } = n.exported, u = c.types.isProgram(r) ? O(n.local.name, r) : n.local;
-              if (l === "default") {
-                let d;
-                c.types.isObjectExpression(u) ? d = u : (
-                  // export default { ... } as Meta<...>
-                  c.types.isTSAsExpression(u) && c.types.isObjectExpression(u.expression) && (d = u.expression)
-                ), !e._meta && d && c.types.isProgram(r) && e._parseMeta(d, r);
-              } else
-                e._storyAnnotations[l] = {}, e._storyStatements[l] = u, e._stories[l] = {
+                self._storyExports[exportName] = decl;
+                self._storyStatements[exportName] = node;
+                let name = (0, import_csf.storyNameFromExport)(exportName);
+                if (self._storyAnnotations[exportName]) {
+                  logger.warn(
+                    `Unexpected annotations for "${exportName}" before story declaration`
+                  );
+                } else {
+                  self._storyAnnotations[exportName] = {};
+                }
+                let storyNode;
+                if (import_babel2.types.isVariableDeclarator(decl)) {
+                  storyNode = import_babel2.types.isTSAsExpression(decl.init) || import_babel2.types.isTSSatisfiesExpression(decl.init) ? decl.
+                  init.expression : decl.init;
+                } else {
+                  storyNode = decl;
+                }
+                const parameters = {};
+                if (import_babel2.types.isObjectExpression(storyNode)) {
+                  parameters.__isArgsStory = true;
+                  storyNode.properties.forEach((p) => {
+                    if (import_babel2.types.isIdentifier(p.key)) {
+                      if (p.key.name === "render") {
+                        parameters.__isArgsStory = isArgsStory(
+                          p.value,
+                          parent,
+                          self
+                        );
+                      } else if (p.key.name === "name" && import_babel2.types.isStringLiteral(p.value)) {
+                        name = p.value.value;
+                      } else if (p.key.name === "storyName" && import_babel2.types.isStringLiteral(p.value)) {
+                        logger.warn(
+                          `Unexpected usage of "storyName" in "${exportName}". Please use "name" instead.`
+                        );
+                      } else if (p.key.name === "parameters" && import_babel2.types.isObjectExpression(p.value)) {
+                        const idProperty = p.value.properties.find(
+                          (property) => import_babel2.types.isObjectProperty(property) && import_babel2.types.isIdentifier(property.key) && property.
+                          key.name === "__id"
+                        );
+                        if (idProperty) {
+                          parameters.__id = idProperty.value.value;
+                        }
+                      }
+                      self._storyAnnotations[exportName][p.key.name] = p.value;
+                    }
+                  });
+                } else {
+                  parameters.__isArgsStory = isArgsStory(storyNode, parent, self);
+                }
+                self._stories[exportName] = {
                   id: "FIXME",
-                  name: l,
-                  parameters: {},
+                  name,
+                  parameters,
                   __stats: {}
                 };
-            }
-          });
+              }
+            });
+          } else if (node.specifiers.length > 0) {
+            node.specifiers.forEach((specifier) => {
+              if (import_babel2.types.isExportSpecifier(specifier) && import_babel2.types.isIdentifier(specifier.exported)) {
+                const { name: exportName } = specifier.exported;
+                const decl = import_babel2.types.isProgram(parent) ? findVarInitialization(specifier.local.name, parent) : specifier.local;
+                if (exportName === "default") {
+                  let metaNode;
+                  if (import_babel2.types.isObjectExpression(decl)) {
+                    metaNode = decl;
+                  } else if (
+                    // export default { ... } as Meta<...>
+                    import_babel2.types.isTSAsExpression(decl) && import_babel2.types.isObjectExpression(decl.expression)
+                  ) {
+                    metaNode = decl.expression;
+                  }
+                  if (!self._meta && metaNode && import_babel2.types.isProgram(parent)) {
+                    self._parseMeta(metaNode, parent);
+                  }
+                } else {
+                  self._storyAnnotations[exportName] = {};
+                  self._storyStatements[exportName] = decl;
+                  self._stories[exportName] = {
+                    id: "FIXME",
+                    name: exportName,
+                    parameters: {},
+                    __stats: {}
+                  };
+                }
+              }
+            });
+          }
         }
       },
       ExpressionStatement: {
-        enter({ node: t, parent: r }) {
-          let { expression: a } = t;
-          if (c.types.isProgram(r) && c.types.isAssignmentExpression(a) && c.types.isMemberExpression(a.left) && c.types.isIdentifier(a.left.
-          object) && c.types.isIdentifier(a.left.property)) {
-            let n = a.left.object.name, l = a.left.property.name, u = a.right;
-            if (e._storyAnnotations[n] && (l === "story" && c.types.isObjectExpression(u) ? u.properties.forEach((d) => {
-              c.types.isIdentifier(d.key) && (e._storyAnnotations[n][d.key.name] = d.value);
-            }) : e._storyAnnotations[n][l] = u), l === "storyName" && c.types.isStringLiteral(u)) {
-              let d = u.value, x = e._stories[n];
-              if (!x)
+        enter({ node, parent }) {
+          const { expression } = node;
+          if (import_babel2.types.isProgram(parent) && import_babel2.types.isAssignmentExpression(expression) && import_babel2.types.isMemberExpression(
+          expression.left) && import_babel2.types.isIdentifier(expression.left.object) && import_babel2.types.isIdentifier(expression.left.property)) {
+            const exportName = expression.left.object.name;
+            const annotationKey = expression.left.property.name;
+            const annotationValue = expression.right;
+            if (self._storyAnnotations[exportName]) {
+              if (annotationKey === "story" && import_babel2.types.isObjectExpression(annotationValue)) {
+                annotationValue.properties.forEach((prop) => {
+                  if (import_babel2.types.isIdentifier(prop.key)) {
+                    self._storyAnnotations[exportName][prop.key.name] = prop.value;
+                  }
+                });
+              } else {
+                self._storyAnnotations[exportName][annotationKey] = annotationValue;
+              }
+            }
+            if (annotationKey === "storyName" && import_babel2.types.isStringLiteral(annotationValue)) {
+              const storyName = annotationValue.value;
+              const story = self._stories[exportName];
+              if (!story) {
                 return;
-              x.name = d;
+              }
+              story.name = storyName;
             }
           }
         }
       },
       CallExpression: {
-        enter({ node: t }) {
-          let { callee: r } = t;
-          if (c.types.isIdentifier(r) && r.name === "storiesOf")
-            throw new Error(T.dedent`
-              Unexpected \`storiesOf\` usage: ${G(t, e._options.fileName)}.
+        enter({ node }) {
+          const { callee } = node;
+          if (import_babel2.types.isIdentifier(callee) && callee.name === "storiesOf") {
+            throw new Error(import_ts_dedent.dedent`
+              Unexpected \`storiesOf\` usage: ${formatLocation(node, self._options.fileName)}.
 
               SB8 does not support \`storiesOf\`. 
             `);
+          }
         }
       },
       ImportDeclaration: {
-        enter({ node: t }) {
-          let { source: r } = t;
-          if (c.types.isStringLiteral(r))
-            e.imports.push(r.value);
-          else
+        enter({ node }) {
+          const { source } = node;
+          if (import_babel2.types.isStringLiteral(source)) {
+            self.imports.push(source.value);
+          } else {
             throw new Error("CSF: unexpected import source");
+          }
         }
       }
-    }), !e._meta)
-      throw new k("missing default export", e._ast, e._options.fileName);
-    let i = Object.entries(e._stories);
-    if (e._meta.title = this._options.makeTitle(e._meta?.title), e._metaAnnotations.play && (e._meta.tags = [...e._meta.tags || [], "play-fn"]),
-    e._stories = i.reduce(
-      (t, [r, a]) => {
-        if (!(0, P.isExportStory)(r, e._meta))
-          return t;
-        let n = a.parameters?.__id ?? (0, P.toId)(e._meta?.id || e._meta?.title, (0, P.storyNameFromExport)(r)), l = { ...a.parameters, __id: n },
-        { includeStories: u } = e._meta || {};
-        r === "__page" && (i.length === 1 || Array.isArray(u) && u.length === 1) && (l.docsOnly = !0), t[r] = { ...a, id: n, parameters: l };
-        let d = e._storyAnnotations[r], { tags: x, play: g } = d;
-        if (x) {
-          let _ = c.types.isIdentifier(x) ? O(x.name, this._ast.program) : x;
-          t[r].tags = oe(_);
+    });
+    if (!self._meta) {
+      throw new NoMetaError("missing default export", self._ast, self._options.fileName);
+    }
+    const entries = Object.entries(self._stories);
+    self._meta.title = this._options.makeTitle(self._meta?.title);
+    if (self._metaAnnotations.play) {
+      self._meta.tags = [...self._meta.tags || [], "play-fn"];
+    }
+    self._stories = entries.reduce(
+      (acc, [key, story]) => {
+        if (!(0, import_csf.isExportStory)(key, self._meta)) {
+          return acc;
+        }
+        const id = story.parameters?.__id ?? (0, import_csf.toId)(self._meta?.id || self._meta?.title, (0, import_csf.storyNameFromExport)(key));
+        const parameters = { ...story.parameters, __id: id };
+        const { includeStories } = self._meta || {};
+        if (key === "__page" && (entries.length === 1 || Array.isArray(includeStories) && includeStories.length === 1)) {
+          parameters.docsOnly = true;
+        }
+        acc[key] = { ...story, id, parameters };
+        const storyAnnotations = self._storyAnnotations[key];
+        const { tags, play } = storyAnnotations;
+        if (tags) {
+          const node = import_babel2.types.isIdentifier(tags) ? findVarInitialization(tags.name, this._ast.program) : tags;
+          acc[key].tags = parseTags(node);
+        }
+        if (play) {
+          acc[key].tags = [...acc[key].tags || [], "play-fn"];
         }
-        g && (t[r].tags = [...t[r].tags || [], "play-fn"]);
-        let b = t[r].__stats;
-        ["play", "render", "loaders", "beforeEach", "globals"].forEach((_) => {
-          b[_] = !!d[_] || !!e._metaAnnotations[_];
+        const stats = acc[key].__stats;
+        ["play", "render", "loaders", "beforeEach", "globals"].forEach((annotation) => {
+          stats[annotation] = !!storyAnnotations[annotation] || !!self._metaAnnotations[annotation];
         });
-        let h = e.getStoryExport(r);
-        return b.storyFn = !!(c.types.isArrowFunctionExpression(h) || c.types.isFunctionDeclaration(h)), b.mount = Xe(d.play ?? e._metaAnnotations.
-        play), b.moduleMock = !!e.imports.find((_) => ce(_)), t;
+        const storyExport = self.getStoryExport(key);
+        stats.storyFn = !!(import_babel2.types.isArrowFunctionExpression(storyExport) || import_babel2.types.isFunctionDeclaration(storyExport));
+        stats.mount = hasMount(storyAnnotations.play ?? self._metaAnnotations.play);
+        stats.moduleMock = !!self.imports.find((fname) => isModuleMock(fname));
+        return acc;
       },
       {}
-    ), Object.keys(e._storyExports).forEach((t) => {
-      (0, P.isExportStory)(t, e._meta) || (delete e._storyExports[t], delete e._storyAnnotations[t], delete e._storyStatements[t]);
-    }), e._namedExportsOrder) {
-      let t = Object.keys(e._storyExports);
-      e._storyExports = le(e._storyExports, e._namedExportsOrder), e._stories = le(e._stories, e._namedExportsOrder);
-      let r = Object.keys(e._storyExports);
-      if (t.length !== r.length)
+    );
+    Object.keys(self._storyExports).forEach((key) => {
+      if (!(0, import_csf.isExportStory)(key, self._meta)) {
+        delete self._storyExports[key];
+        delete self._storyAnnotations[key];
+        delete self._storyStatements[key];
+      }
+    });
+    if (self._namedExportsOrder) {
+      const unsortedExports = Object.keys(self._storyExports);
+      self._storyExports = sortExports(self._storyExports, self._namedExportsOrder);
+      self._stories = sortExports(self._stories, self._namedExportsOrder);
+      const sortedExports = Object.keys(self._storyExports);
+      if (unsortedExports.length !== sortedExports.length) {
         throw new Error(
-          `Missing exports after sort: ${t.filter(
-            (a) => !r.includes(a)
+          `Missing exports after sort: ${unsortedExports.filter(
+            (key) => !sortedExports.includes(key)
           )}`
         );
+      }
     }
-    return e;
+    return self;
   }
   get meta() {
     return this._meta;
@@ -453,233 +630,360 @@ var G = /* @__PURE__ */ p((s, e) => {
     return Object.values(this._stories);
   }
   get indexInputs() {
-    let { fileName: e } = this._options;
-    if (!e)
+    const { fileName } = this._options;
+    if (!fileName) {
       throw new Error(
-        T.dedent`Cannot automatically create index inputs with CsfFile.indexInputs because the CsfFile instance was created without a the fileName option.
+        import_ts_dedent.dedent`Cannot automatically create index inputs with CsfFile.indexInputs because the CsfFile instance was created without a the fileName option.
         Either add the fileName option when creating the CsfFile instance, or create the index inputs manually.`
       );
-    return Object.entries(this._stories).map(([i, t]) => {
-      let r = [...this._meta?.tags ?? [], ...t.tags ?? []];
+    }
+    return Object.entries(this._stories).map(([exportName, story]) => {
+      const tags = [...this._meta?.tags ?? [], ...story.tags ?? []];
       return {
         type: "story",
-        importPath: e,
+        importPath: fileName,
         rawComponentPath: this._rawComponentPath,
-        exportName: i,
-        name: t.name,
+        exportName,
+        name: story.name,
         title: this.meta?.title,
         metaId: this.meta?.id,
-        tags: r,
-        __id: t.id,
-        __stats: t.__stats
+        tags,
+        __id: story.id,
+        __stats: story.__stats
       };
     });
   }
-}, pe = /* @__PURE__ */ p(({
-  code: s,
-  filename: e = "",
-  ast: i
-}) => new c.BabelFileClass({ filename: e }, { code: s, ast: i ?? (0, c.babelParse)(s) }), "babelParseFile"), q = /* @__PURE__ */ p((s, e) => {
-  let i = (0, c.babelParse)(s), t = pe({ code: s, filename: e.fileName, ast: i });
-  return new $(i, e, t);
-}, "loadCsf"), J = /* @__PURE__ */ p((s, e = { sourceMaps: !1 }, i) => {
-  let t = (0, c.generate)(s._ast, e, i);
-  return e.sourceMaps ? t : t.code;
-}, "formatCsf"), fe = /* @__PURE__ */ p((s, e = {}) => c.recast.print(s._ast, e), "printCsf"), He = /* @__PURE__ */ p(async (s, e) => {
-  let i = (await (0, U.readFile)(s, "utf-8")).toString();
-  return q(i, { ...e, fileName: s });
-}, "readCsf"), Ye = /* @__PURE__ */ p(async (s, e) => {
-  if (!(e || s._options.fileName))
+};
+var babelParseFile = /* @__PURE__ */ __name(({
+  code,
+  filename = "",
+  ast
+}) => {
+  return new import_babel2.BabelFileClass({ filename }, { code, ast: ast ?? (0, import_babel2.babelParse)(code) });
+}, "babelParseFile");
+var loadCsf = /* @__PURE__ */ __name((code, options) => {
+  const ast = (0, import_babel2.babelParse)(code);
+  const file = babelParseFile({ code, filename: options.fileName, ast });
+  return new CsfFile(ast, options, file);
+}, "loadCsf");
+var formatCsf = /* @__PURE__ */ __name((csf, options = { sourceMaps: false }, code) => {
+  const result = (0, import_babel2.generate)(csf._ast, options, code);
+  if (options.sourceMaps) {
+    return result;
+  }
+  return result.code;
+}, "formatCsf");
+var printCsf = /* @__PURE__ */ __name((csf, options = {}) => {
+  return import_babel2.recast.print(csf._ast, options);
+}, "printCsf");
+var readCsf = /* @__PURE__ */ __name(async (fileName, options) => {
+  const code = (await (0, import_promises.readFile)(fileName, "utf-8")).toString();
+  return loadCsf(code, { ...options, fileName });
+}, "readCsf");
+var writeCsf = /* @__PURE__ */ __name(async (csf, fileName) => {
+  const fname = fileName || csf._options.fileName;
+  if (!fname) {
     throw new Error("Please specify a fileName for writeCsf");
-  await (0, U.writeFile)(e, fe(s).code);
+  }
+  await (0, import_promises.writeFile)(fileName, printCsf(csf).code);
 }, "writeCsf");
 
 // src/csf-tools/ConfigFile.ts
-var z = require("node:fs/promises"), o = require("@storybook/core/babel"), de = M(C(), 1);
-var K = console, X = /* @__PURE__ */ p(({
-  expectedType: s,
-  foundType: e,
-  node: i
+var import_promises2 = require("node:fs/promises");
+var import_babel3 = require("@storybook/core/babel");
+var import_ts_dedent2 = __toESM(require_dist(), 1);
+var logger2 = console;
+var getCsfParsingErrorMessage = /* @__PURE__ */ __name(({
+  expectedType,
+  foundType,
+  node
 }) => {
-  let t = "";
-  if (i)
+  let nodeInfo = "";
+  if (node) {
     try {
-      t = JSON.stringify(i);
-    } catch {
+      nodeInfo = JSON.stringify(node);
+    } catch (e) {
     }
-  return de.dedent`
-      CSF Parsing error: Expected '${s}' but found '${e}' instead in '${i?.type}'.
-      ${t}
+  }
+  return import_ts_dedent2.dedent`
+      CSF Parsing error: Expected '${expectedType}' but found '${foundType}' instead in '${node?.type}'.
+      ${nodeInfo}
     `;
-}, "getCsfParsingErrorMessage"), V = /* @__PURE__ */ p((s) => o.types.isIdentifier(s.key) ? s.key.name : o.types.isStringLiteral(s.key) ? s.
-key.value : null, "propKey"), B = /* @__PURE__ */ p((s) => o.types.isTSAsExpression(s) || o.types.isTSSatisfiesExpression(s) ? B(s.expression) :
-s, "unwrap"), ue = /* @__PURE__ */ p((s, e) => {
-  if (s.length === 0)
-    return e;
-  if (o.types.isObjectExpression(e)) {
-    let [i, ...t] = s, r = e.properties.find((a) => V(a) === i);
-    if (r)
-      return ue(t, r.value);
-  }
-}, "_getPath"), me = /* @__PURE__ */ p((s, e) => {
-  if (s.length === 0) {
-    if (o.types.isObjectExpression(e))
-      return e.properties;
+}, "getCsfParsingErrorMessage");
+var propKey = /* @__PURE__ */ __name((p) => {
+  if (import_babel3.types.isIdentifier(p.key)) {
+    return p.key.name;
+  }
+  if (import_babel3.types.isStringLiteral(p.key)) {
+    return p.key.value;
+  }
+  return null;
+}, "propKey");
+var unwrap = /* @__PURE__ */ __name((node) => {
+  if (import_babel3.types.isTSAsExpression(node) || import_babel3.types.isTSSatisfiesExpression(node)) {
+    return unwrap(node.expression);
+  }
+  return node;
+}, "unwrap");
+var _getPath = /* @__PURE__ */ __name((path, node) => {
+  if (path.length === 0) {
+    return node;
+  }
+  if (import_babel3.types.isObjectExpression(node)) {
+    const [first, ...rest] = path;
+    const field = node.properties.find((p) => propKey(p) === first);
+    if (field) {
+      return _getPath(rest, field.value);
+    }
+  }
+  return void 0;
+}, "_getPath");
+var _getPathProperties = /* @__PURE__ */ __name((path, node) => {
+  if (path.length === 0) {
+    if (import_babel3.types.isObjectExpression(node)) {
+      return node.properties;
+    }
     throw new Error("Expected object expression");
   }
-  if (o.types.isObjectExpression(e)) {
-    let [i, ...t] = s, r = e.properties.find((a) => V(a) === i);
-    if (r)
-      return t.length === 0 ? e.properties : me(t, r.value);
-  }
-}, "_getPathProperties"), ge = /* @__PURE__ */ p((s, e) => {
-  let i = null, t = null;
-  return e.body.find((r) => (o.types.isVariableDeclaration(r) ? t = r.declarations : o.types.isExportNamedDeclaration(r) && o.types.isVariableDeclaration(
-  r.declaration) && (t = r.declaration.declarations), t && t.find((a) => o.types.isVariableDeclarator(a) && o.types.isIdentifier(a.id) && a.
-  id.name === s ? (i = a, !0) : !1))), i;
-}, "_findVarDeclarator"), I = /* @__PURE__ */ p((s, e) => ge(s, e)?.init, "_findVarInitialization"), A = /* @__PURE__ */ p((s, e) => {
-  if (s.length === 0)
-    return e;
-  let [i, ...t] = s, r = A(t, e);
-  return o.types.objectExpression([o.types.objectProperty(o.types.identifier(i), r)]);
-}, "_makeObjectExpression"), Q = /* @__PURE__ */ p((s, e, i) => {
-  let [t, ...r] = s, a = i.properties.find(
-    (n) => V(n) === t
-  );
-  a ? o.types.isObjectExpression(a.value) && r.length > 0 ? Q(r, e, a.value) : a.value = A(r, e) : i.properties.push(
-    o.types.objectProperty(o.types.identifier(t), A(r, e))
+  if (import_babel3.types.isObjectExpression(node)) {
+    const [first, ...rest] = path;
+    const field = node.properties.find((p) => propKey(p) === first);
+    if (field) {
+      if (rest.length === 0) {
+        return node.properties;
+      }
+      return _getPathProperties(rest, field.value);
+    }
+  }
+  return void 0;
+}, "_getPathProperties");
+var _findVarDeclarator = /* @__PURE__ */ __name((identifier, program) => {
+  let declarator = null;
+  let declarations = null;
+  program.body.find((node) => {
+    if (import_babel3.types.isVariableDeclaration(node)) {
+      declarations = node.declarations;
+    } else if (import_babel3.types.isExportNamedDeclaration(node) && import_babel3.types.isVariableDeclaration(node.declaration)) {
+      declarations = node.declaration.declarations;
+    }
+    return declarations && declarations.find((decl) => {
+      if (import_babel3.types.isVariableDeclarator(decl) && import_babel3.types.isIdentifier(decl.id) && decl.id.name === identifier) {
+        declarator = decl;
+        return true;
+      }
+      return false;
+    });
+  });
+  return declarator;
+}, "_findVarDeclarator");
+var _findVarInitialization = /* @__PURE__ */ __name((identifier, program) => {
+  const declarator = _findVarDeclarator(identifier, program);
+  return declarator?.init;
+}, "_findVarInitialization");
+var _makeObjectExpression = /* @__PURE__ */ __name((path, value) => {
+  if (path.length === 0) {
+    return value;
+  }
+  const [first, ...rest] = path;
+  const innerExpression = _makeObjectExpression(rest, value);
+  return import_babel3.types.objectExpression([import_babel3.types.objectProperty(import_babel3.types.identifier(first), innerExpression)]);
+}, "_makeObjectExpression");
+var _updateExportNode = /* @__PURE__ */ __name((path, expr, existing) => {
+  const [first, ...rest] = path;
+  const existingField = existing.properties.find(
+    (p) => propKey(p) === first
   );
-}, "_updateExportNode"), W = class {
-  constructor(e, i, t) {
+  if (!existingField) {
+    existing.properties.push(
+      import_babel3.types.objectProperty(import_babel3.types.identifier(first), _makeObjectExpression(rest, expr))
+    );
+  } else if (import_babel3.types.isObjectExpression(existingField.value) && rest.length > 0) {
+    _updateExportNode(rest, expr, existingField.value);
+  } else {
+    existingField.value = _makeObjectExpression(rest, expr);
+  }
+}, "_updateExportNode");
+var ConfigFile = class {
+  constructor(ast, code, fileName) {
     this._exports = {};
     // FIXME: this is a hack. this is only used in the case where the user is
     // modifying a named export that's a scalar. The _exports map is not suitable
     // for that. But rather than refactor the whole thing, we just use this as a stopgap.
     this._exportDecls = {};
-    this.hasDefaultExport = !1;
-    this._ast = e, this._code = i, this.fileName = t;
+    this.hasDefaultExport = false;
+    this._ast = ast;
+    this._code = code;
+    this.fileName = fileName;
   }
   static {
-    p(this, "ConfigFile");
+    __name(this, "ConfigFile");
   }
   parse() {
-    let e = this;
-    return (0, o.traverse)(this._ast, {
+    const self = this;
+    (0, import_babel3.traverse)(this._ast, {
       ExportDefaultDeclaration: {
-        enter({ node: i, parent: t }) {
-          e.hasDefaultExport = !0;
-          let r = o.types.isIdentifier(i.declaration) && o.types.isProgram(t) ? I(i.declaration.name, t) : i.declaration;
-          r = B(r), o.types.isObjectExpression(r) ? (e._exportsObject = r, r.properties.forEach((a) => {
-            let n = V(a);
-            if (n) {
-              let l = a.value;
-              o.types.isIdentifier(l) && (l = I(l.name, t)), e._exports[n] = l;
-            }
-          })) : K.warn(
-            X({
-              expectedType: "ObjectExpression",
-              foundType: r?.type,
-              node: r || i.declaration
-            })
-          );
+        enter({ node, parent }) {
+          self.hasDefaultExport = true;
+          let decl = import_babel3.types.isIdentifier(node.declaration) && import_babel3.types.isProgram(parent) ? _findVarInitialization(node.
+          declaration.name, parent) : node.declaration;
+          decl = unwrap(decl);
+          if (import_babel3.types.isObjectExpression(decl)) {
+            self._exportsObject = decl;
+            decl.properties.forEach((p) => {
+              const exportName = propKey(p);
+              if (exportName) {
+                let exportVal = p.value;
+                if (import_babel3.types.isIdentifier(exportVal)) {
+                  exportVal = _findVarInitialization(exportVal.name, parent);
+                }
+                self._exports[exportName] = exportVal;
+              }
+            });
+          } else {
+            logger2.warn(
+              getCsfParsingErrorMessage({
+                expectedType: "ObjectExpression",
+                foundType: decl?.type,
+                node: decl || node.declaration
+              })
+            );
+          }
         }
       },
       ExportNamedDeclaration: {
-        enter({ node: i, parent: t }) {
-          o.types.isVariableDeclaration(i.declaration) ? i.declaration.declarations.forEach((r) => {
-            if (o.types.isVariableDeclarator(r) && o.types.isIdentifier(r.id)) {
-              let { name: a } = r.id, n = r.init;
-              o.types.isIdentifier(n) && (n = I(n.name, t)), e._exports[a] = n, e._exportDecls[a] = r;
-            }
-          }) : i.specifiers ? i.specifiers.forEach((r) => {
-            if (o.types.isExportSpecifier(r) && o.types.isIdentifier(r.local) && o.types.isIdentifier(r.exported)) {
-              let { name: a } = r.local, { name: n } = r.exported, l = ge(a, t);
-              e._exports[n] = l.init, e._exportDecls[n] = l;
-            }
-          }) : K.warn(
-            X({
-              expectedType: "VariableDeclaration",
-              foundType: i.declaration?.type,
-              node: i.declaration
-            })
-          );
+        enter({ node, parent }) {
+          if (import_babel3.types.isVariableDeclaration(node.declaration)) {
+            node.declaration.declarations.forEach((decl) => {
+              if (import_babel3.types.isVariableDeclarator(decl) && import_babel3.types.isIdentifier(decl.id)) {
+                const { name: exportName } = decl.id;
+                let exportVal = decl.init;
+                if (import_babel3.types.isIdentifier(exportVal)) {
+                  exportVal = _findVarInitialization(exportVal.name, parent);
+                }
+                self._exports[exportName] = exportVal;
+                self._exportDecls[exportName] = decl;
+              }
+            });
+          } else if (node.specifiers) {
+            node.specifiers.forEach((spec) => {
+              if (import_babel3.types.isExportSpecifier(spec) && import_babel3.types.isIdentifier(spec.local) && import_babel3.types.isIdentifier(
+              spec.exported)) {
+                const { name: localName } = spec.local;
+                const { name: exportName } = spec.exported;
+                const decl = _findVarDeclarator(localName, parent);
+                self._exports[exportName] = decl.init;
+                self._exportDecls[exportName] = decl;
+              }
+            });
+          } else {
+            logger2.warn(
+              getCsfParsingErrorMessage({
+                expectedType: "VariableDeclaration",
+                foundType: node.declaration?.type,
+                node: node.declaration
+              })
+            );
+          }
         }
       },
       ExpressionStatement: {
-        enter({ node: i, parent: t }) {
-          if (o.types.isAssignmentExpression(i.expression) && i.expression.operator === "=") {
-            let { left: r, right: a } = i.expression;
-            if (o.types.isMemberExpression(r) && o.types.isIdentifier(r.object) && r.object.name === "module" && o.types.isIdentifier(r.property) &&
-            r.property.name === "exports") {
-              let n = a;
-              o.types.isIdentifier(a) && (n = I(a.name, t)), n = B(n), o.types.isObjectExpression(n) ? (e._exportsObject = n, n.properties.forEach(
-              (l) => {
-                let u = V(l);
-                if (u) {
-                  let d = l.value;
-                  o.types.isIdentifier(d) && (d = I(
-                    d.name,
-                    t
-                  )), e._exports[u] = d;
-                }
-              })) : K.warn(
-                X({
-                  expectedType: "ObjectExpression",
-                  foundType: n?.type,
-                  node: n
-                })
-              );
+        enter({ node, parent }) {
+          if (import_babel3.types.isAssignmentExpression(node.expression) && node.expression.operator === "=") {
+            const { left, right } = node.expression;
+            if (import_babel3.types.isMemberExpression(left) && import_babel3.types.isIdentifier(left.object) && left.object.name === "modul\
+e" && import_babel3.types.isIdentifier(left.property) && left.property.name === "exports") {
+              let exportObject = right;
+              if (import_babel3.types.isIdentifier(right)) {
+                exportObject = _findVarInitialization(right.name, parent);
+              }
+              exportObject = unwrap(exportObject);
+              if (import_babel3.types.isObjectExpression(exportObject)) {
+                self._exportsObject = exportObject;
+                exportObject.properties.forEach((p) => {
+                  const exportName = propKey(p);
+                  if (exportName) {
+                    let exportVal = p.value;
+                    if (import_babel3.types.isIdentifier(exportVal)) {
+                      exportVal = _findVarInitialization(
+                        exportVal.name,
+                        parent
+                      );
+                    }
+                    self._exports[exportName] = exportVal;
+                  }
+                });
+              } else {
+                logger2.warn(
+                  getCsfParsingErrorMessage({
+                    expectedType: "ObjectExpression",
+                    foundType: exportObject?.type,
+                    node: exportObject
+                  })
+                );
+              }
             }
           }
         }
       }
-    }), e;
-  }
-  getFieldNode(e) {
-    let [i, ...t] = e, r = this._exports[i];
-    if (r)
-      return ue(t, r);
-  }
-  getFieldProperties(e) {
-    let [i, ...t] = e, r = this._exports[i];
-    if (r)
-      return me(t, r);
-  }
-  getFieldValue(e) {
-    let i = this.getFieldNode(e);
-    if (i) {
-      let { code: t } = (0, o.generate)(i, {});
-      return (0, eval)(`(() => (${t}))()`);
+    });
+    return self;
+  }
+  getFieldNode(path) {
+    const [root, ...rest] = path;
+    const exported = this._exports[root];
+    if (!exported) {
+      return void 0;
+    }
+    return _getPath(rest, exported);
+  }
+  getFieldProperties(path) {
+    const [root, ...rest] = path;
+    const exported = this._exports[root];
+    if (!exported) {
+      return void 0;
+    }
+    return _getPathProperties(rest, exported);
+  }
+  getFieldValue(path) {
+    const node = this.getFieldNode(path);
+    if (node) {
+      const { code } = (0, import_babel3.generate)(node, {});
+      const value = (0, eval)(`(() => (${code}))()`);
+      return value;
     }
+    return void 0;
   }
-  getSafeFieldValue(e) {
+  getSafeFieldValue(path) {
     try {
-      return this.getFieldValue(e);
-    } catch {
+      return this.getFieldValue(path);
+    } catch (e) {
     }
+    return void 0;
   }
-  setFieldNode(e, i) {
-    let [t, ...r] = e, a = this._exports[t];
-    if (this._exportsObject)
-      Q(e, i, this._exportsObject), this._exports[e[0]] = i;
-    else if (a && o.types.isObjectExpression(a) && r.length > 0)
-      Q(r, i, a);
-    else if (a && r.length === 0 && this._exportDecls[e[0]]) {
-      let n = this._exportDecls[e[0]];
-      n.init = A([], i);
+  setFieldNode(path, expr) {
+    const [first, ...rest] = path;
+    const exportNode = this._exports[first];
+    if (this._exportsObject) {
+      _updateExportNode(path, expr, this._exportsObject);
+      this._exports[path[0]] = expr;
+    } else if (exportNode && import_babel3.types.isObjectExpression(exportNode) && rest.length > 0) {
+      _updateExportNode(rest, expr, exportNode);
+    } else if (exportNode && rest.length === 0 && this._exportDecls[path[0]]) {
+      const decl = this._exportDecls[path[0]];
+      decl.init = _makeObjectExpression([], expr);
+    } else if (this.hasDefaultExport) {
+      throw new Error(
+        `Could not set the "${path.join(
+          "."
+        )}" field as the default export is not an object in this file.`
+      );
     } else {
-      if (this.hasDefaultExport)
-        throw new Error(
-          `Could not set the "${e.join(
-            "."
-          )}" field as the default export is not an object in this file.`
-        );
-      {
-        let n = A(r, i), l = o.types.exportNamedDeclaration(
-          o.types.variableDeclaration("const", [o.types.variableDeclarator(o.types.identifier(t), n)])
-        );
-        this._exports[t] = n, this._ast.program.body.push(l);
-      }
+      const exportObj = _makeObjectExpression(rest, expr);
+      const newExport = import_babel3.types.exportNamedDeclaration(
+        import_babel3.types.variableDeclaration("const", [import_babel3.types.variableDeclarator(import_babel3.types.identifier(first), exportObj)])
+      );
+      this._exports[first] = exportObj;
+      this._ast.program.body.push(newExport);
     }
   }
   /**
@@ -693,10 +997,12 @@ s, "unwrap"), ue = /* @__PURE__ */ p((s, e) => {
    *
    * @returns The name of a node in a given path, supporting the following formats:
    */
-  getNameFromPath(e) {
-    let i = this.getFieldNode(e);
-    if (i)
-      return this._getPresetValue(i, "name");
+  getNameFromPath(path) {
+    const node = this.getFieldNode(path);
+    if (!node) {
+      return void 0;
+    }
+    return this._getPresetValue(node, "name");
   }
   /**
    * Returns an array of names of a node in a given path, supporting the following formats:
@@ -711,21 +1017,27 @@ s, "unwrap"), ue = /* @__PURE__ */ p((s, e) => {
    * getNamesFromPath(['addons']);
    * ```
    */
-  getNamesFromPath(e) {
-    let i = this.getFieldNode(e);
-    if (!i)
-      return;
-    let t = [];
-    return o.types.isArrayExpression(i) && i.elements.forEach((r) => {
-      t.push(this._getPresetValue(r, "name"));
-    }), t;
-  }
-  _getPnpWrappedValue(e) {
-    if (o.types.isCallExpression(e)) {
-      let i = e.arguments[0];
-      if (o.types.isStringLiteral(i))
-        return i.value;
+  getNamesFromPath(path) {
+    const node = this.getFieldNode(path);
+    if (!node) {
+      return void 0;
+    }
+    const pathNames = [];
+    if (import_babel3.types.isArrayExpression(node)) {
+      node.elements.forEach((element) => {
+        pathNames.push(this._getPresetValue(element, "name"));
+      });
     }
+    return pathNames;
+  }
+  _getPnpWrappedValue(node) {
+    if (import_babel3.types.isCallExpression(node)) {
+      const arg = node.arguments[0];
+      if (import_babel3.types.isStringLiteral(arg)) {
+        return arg.value;
+      }
+    }
+    return void 0;
   }
   /**
    * Given a node and a fallback property, returns a **non-evaluated** string value of the node.
@@ -733,121 +1045,176 @@ s, "unwrap"), ue = /* @__PURE__ */ p((s, e) => {
    * 1. `{ node: 'value' }`
    * 2. `{ node: { fallbackProperty: 'value' } }`
    */
-  _getPresetValue(e, i) {
-    let t;
-    if (o.types.isStringLiteral(e) ? t = e.value : o.types.isObjectExpression(e) && e.properties.forEach((r) => {
-      o.types.isObjectProperty(r) && o.types.isIdentifier(r.key) && r.key.name === i && (o.types.isStringLiteral(r.value) ? t = r.value.value :
-      t = this._getPnpWrappedValue(r.value)), o.types.isObjectProperty(r) && o.types.isStringLiteral(r.key) && r.key.value === "name" && o.types.
-      isStringLiteral(r.value) && (t = r.value.value);
-    }), !t)
+  _getPresetValue(node, fallbackProperty) {
+    let value;
+    if (import_babel3.types.isStringLiteral(node)) {
+      value = node.value;
+    } else if (import_babel3.types.isObjectExpression(node)) {
+      node.properties.forEach((prop) => {
+        if (import_babel3.types.isObjectProperty(prop) && import_babel3.types.isIdentifier(prop.key) && prop.key.name === fallbackProperty) {
+          if (import_babel3.types.isStringLiteral(prop.value)) {
+            value = prop.value.value;
+          } else {
+            value = this._getPnpWrappedValue(prop.value);
+          }
+        }
+        if (import_babel3.types.isObjectProperty(prop) && import_babel3.types.isStringLiteral(prop.key) && prop.key.value === "name" && import_babel3.types.
+        isStringLiteral(prop.value)) {
+          value = prop.value.value;
+        }
+      });
+    }
+    if (!value) {
       throw new Error(
-        `The given node must be a string literal or an object expression with a "${i}" property that is a string literal.`
+        `The given node must be a string literal or an object expression with a "${fallbackProperty}" property that is a string literal.`
       );
-    return t;
+    }
+    return value;
   }
-  removeField(e) {
-    let i = /* @__PURE__ */ p((r, a) => {
-      let n = r.findIndex(
-        (l) => o.types.isIdentifier(l.key) && l.key.name === a || o.types.isStringLiteral(l.key) && l.key.value === a
+  removeField(path) {
+    const removeProperty = /* @__PURE__ */ __name((properties2, prop) => {
+      const index = properties2.findIndex(
+        (p) => import_babel3.types.isIdentifier(p.key) && p.key.name === prop || import_babel3.types.isStringLiteral(p.key) && p.key.value ===
+        prop
       );
-      n >= 0 && r.splice(n, 1);
+      if (index >= 0) {
+        properties2.splice(index, 1);
+      }
     }, "removeProperty");
-    if (e.length === 1) {
-      let r = !1;
-      if (this._ast.program.body.forEach((a) => {
-        if (o.types.isExportNamedDeclaration(a) && o.types.isVariableDeclaration(a.declaration)) {
-          let n = a.declaration.declarations[0];
-          o.types.isIdentifier(n.id) && n.id.name === e[0] && (this._ast.program.body.splice(this._ast.program.body.indexOf(a), 1), r = !0);
+    if (path.length === 1) {
+      let removedRootProperty = false;
+      this._ast.program.body.forEach((node) => {
+        if (import_babel3.types.isExportNamedDeclaration(node) && import_babel3.types.isVariableDeclaration(node.declaration)) {
+          const decl = node.declaration.declarations[0];
+          if (import_babel3.types.isIdentifier(decl.id) && decl.id.name === path[0]) {
+            this._ast.program.body.splice(this._ast.program.body.indexOf(node), 1);
+            removedRootProperty = true;
+          }
         }
-        if (o.types.isExportDefaultDeclaration(a)) {
-          let n = a.declaration;
-          if (o.types.isIdentifier(n) && (n = I(n.name, this._ast.program)), n = B(n), o.types.isObjectExpression(n)) {
-            let l = n.properties;
-            i(l, e[0]), r = !0;
+        if (import_babel3.types.isExportDefaultDeclaration(node)) {
+          let decl = node.declaration;
+          if (import_babel3.types.isIdentifier(decl)) {
+            decl = _findVarInitialization(decl.name, this._ast.program);
+          }
+          decl = unwrap(decl);
+          if (import_babel3.types.isObjectExpression(decl)) {
+            const properties2 = decl.properties;
+            removeProperty(properties2, path[0]);
+            removedRootProperty = true;
           }
         }
-        if (o.types.isExpressionStatement(a) && o.types.isAssignmentExpression(a.expression) && o.types.isMemberExpression(a.expression.left) &&
-        o.types.isIdentifier(a.expression.left.object) && a.expression.left.object.name === "module" && o.types.isIdentifier(a.expression.left.
-        property) && a.expression.left.property.name === "exports" && o.types.isObjectExpression(a.expression.right)) {
-          let n = a.expression.right.properties;
-          i(n, e[0]), r = !0;
+        if (import_babel3.types.isExpressionStatement(node) && import_babel3.types.isAssignmentExpression(node.expression) && import_babel3.types.
+        isMemberExpression(node.expression.left) && import_babel3.types.isIdentifier(node.expression.left.object) && node.expression.left.object.
+        name === "module" && import_babel3.types.isIdentifier(node.expression.left.property) && node.expression.left.property.name === "expo\
+rts" && import_babel3.types.isObjectExpression(node.expression.right)) {
+          const properties2 = node.expression.right.properties;
+          removeProperty(properties2, path[0]);
+          removedRootProperty = true;
         }
-      }), r)
+      });
+      if (removedRootProperty) {
         return;
+      }
     }
-    let t = this.getFieldProperties(e);
-    if (t) {
-      let r = e.at(-1);
-      i(t, r);
+    const properties = this.getFieldProperties(path);
+    if (properties) {
+      const lastPath = path.at(-1);
+      removeProperty(properties, lastPath);
     }
   }
-  appendValueToArray(e, i) {
-    let t = this.valueToNode(i);
-    t && this.appendNodeToArray(e, t);
+  appendValueToArray(path, value) {
+    const node = this.valueToNode(value);
+    if (node) {
+      this.appendNodeToArray(path, node);
+    }
   }
-  appendNodeToArray(e, i) {
-    let t = this.getFieldNode(e);
-    if (!t)
-      this.setFieldNode(e, o.types.arrayExpression([i]));
-    else if (o.types.isArrayExpression(t))
-      t.elements.push(i);
-    else
-      throw new Error(`Expected array at '${e.join(".")}', got '${t.type}'`);
+  appendNodeToArray(path, node) {
+    const current = this.getFieldNode(path);
+    if (!current) {
+      this.setFieldNode(path, import_babel3.types.arrayExpression([node]));
+    } else if (import_babel3.types.isArrayExpression(current)) {
+      current.elements.push(node);
+    } else {
+      throw new Error(`Expected array at '${path.join(".")}', got '${current.type}'`);
+    }
   }
   /**
    * Specialized helper to remove addons or other array entries that can either be strings or
    * objects with a name property.
    */
-  removeEntryFromArray(e, i) {
-    let t = this.getFieldNode(e);
-    if (t)
-      if (o.types.isArrayExpression(t)) {
-        let r = t.elements.findIndex((a) => o.types.isStringLiteral(a) ? a.value === i : o.types.isObjectExpression(a) ? this._getPresetValue(
-        a, "name") === i : this._getPnpWrappedValue(a) === i);
-        if (r >= 0)
-          t.elements.splice(r, 1);
-        else
-          throw new Error(`Could not find '${i}' in array at '${e.join(".")}'`);
-      } else
-        throw new Error(`Expected array at '${e.join(".")}', got '${t.type}'`);
+  removeEntryFromArray(path, value) {
+    const current = this.getFieldNode(path);
+    if (!current) {
+      return;
+    }
+    if (import_babel3.types.isArrayExpression(current)) {
+      const index = current.elements.findIndex((element) => {
+        if (import_babel3.types.isStringLiteral(element)) {
+          return element.value === value;
+        }
+        if (import_babel3.types.isObjectExpression(element)) {
+          const name = this._getPresetValue(element, "name");
+          return name === value;
+        }
+        return this._getPnpWrappedValue(element) === value;
+      });
+      if (index >= 0) {
+        current.elements.splice(index, 1);
+      } else {
+        throw new Error(`Could not find '${value}' in array at '${path.join(".")}'`);
+      }
+    } else {
+      throw new Error(`Expected array at '${path.join(".")}', got '${current.type}'`);
+    }
   }
   _inferQuotes() {
     if (!this._quotes) {
-      let e = (this._ast.tokens || []).slice(0, 500).reduce(
-        (i, t) => (t.type.label === "string" && (i[this._code[t.start]] += 1), i),
+      const occurrences = (this._ast.tokens || []).slice(0, 500).reduce(
+        (acc, token) => {
+          if (token.type.label === "string") {
+            acc[this._code[token.start]] += 1;
+          }
+          return acc;
+        },
         { "'": 0, '"': 0 }
       );
-      this._quotes = e["'"] > e['"'] ? "single" : "double";
+      this._quotes = occurrences["'"] > occurrences['"'] ? "single" : "double";
     }
     return this._quotes;
   }
-  valueToNode(e) {
-    let i = this._inferQuotes(), t;
-    if (i === "single") {
-      let { code: r } = (0, o.generate)(o.types.valueToNode(e), { jsescOption: { quotes: i } }), a = (0, o.babelParse)(`const __x = ${r}`);
-      (0, o.traverse)(a, {
+  valueToNode(value) {
+    const quotes = this._inferQuotes();
+    let valueNode;
+    if (quotes === "single") {
+      const { code } = (0, import_babel3.generate)(import_babel3.types.valueToNode(value), { jsescOption: { quotes } });
+      const program = (0, import_babel3.babelParse)(`const __x = ${code}`);
+      (0, import_babel3.traverse)(program, {
         VariableDeclaration: {
-          enter({ node: n }) {
-            n.declarations.length === 1 && o.types.isVariableDeclarator(n.declarations[0]) && o.types.isIdentifier(n.declarations[0].id) && n.
-            declarations[0].id.name === "__x" && (t = n.declarations[0].init);
+          enter({ node }) {
+            if (node.declarations.length === 1 && import_babel3.types.isVariableDeclarator(node.declarations[0]) && import_babel3.types.isIdentifier(
+            node.declarations[0].id) && node.declarations[0].id.name === "__x") {
+              valueNode = node.declarations[0].init;
+            }
           }
         }
       });
-    } else
-      t = o.types.valueToNode(e);
-    return t;
+    } else {
+      valueNode = import_babel3.types.valueToNode(value);
+    }
+    return valueNode;
   }
-  setFieldValue(e, i) {
-    let t = this.valueToNode(i);
-    if (!t)
-      throw new Error(`Unexpected value ${JSON.stringify(i)}`);
-    this.setFieldNode(e, t);
+  setFieldValue(path, value) {
+    const valueNode = this.valueToNode(value);
+    if (!valueNode) {
+      throw new Error(`Unexpected value ${JSON.stringify(value)}`);
+    }
+    this.setFieldNode(path, valueNode);
   }
   getBodyDeclarations() {
     return this._ast.program.body;
   }
-  setBodyDeclaration(e) {
-    this._ast.program.body.push(e);
+  setBodyDeclaration(declaration) {
+    this._ast.program.body.push(declaration);
   }
   /**
    * Import specifiers for a specific require import
@@ -866,43 +1233,63 @@ s, "unwrap"), ue = /* @__PURE__ */ p((s, e) => {
    *   import will be set. Otherwise, an array of named imports will be set
    * @param fromImport - The module to import from
    */
-  setRequireImport(e, i) {
-    let t = this._ast.program.body.find(
-      (n) => o.types.isVariableDeclaration(n) && n.declarations.length === 1 && o.types.isVariableDeclarator(n.declarations[0]) && o.types.isCallExpression(
-      n.declarations[0].init) && o.types.isIdentifier(n.declarations[0].init.callee) && n.declarations[0].init.callee.name === "require" && o.types.
-      isStringLiteral(n.declarations[0].init.arguments[0]) && n.declarations[0].init.arguments[0].value === i
-    ), r = /* @__PURE__ */ p((n) => o.types.isObjectPattern(t?.declarations[0].id) && t?.declarations[0].id.properties.find(
-      (l) => o.types.isObjectProperty(l) && o.types.isIdentifier(l.key) && l.key.name === n
-    ), "hasRequireSpecifier"), a = /* @__PURE__ */ p((n, l) => n.declarations.length === 1 && o.types.isVariableDeclarator(n.declarations[0]) &&
-    o.types.isIdentifier(n.declarations[0].id) && n.declarations[0].id.name === l, "hasDefaultRequireSpecifier");
-    if (typeof e == "string") {
-      let n = /* @__PURE__ */ p(() => {
+  setRequireImport(importSpecifier, fromImport) {
+    const requireDeclaration = this._ast.program.body.find(
+      (node) => import_babel3.types.isVariableDeclaration(node) && node.declarations.length === 1 && import_babel3.types.isVariableDeclarator(
+      node.declarations[0]) && import_babel3.types.isCallExpression(node.declarations[0].init) && import_babel3.types.isIdentifier(node.declarations[0].
+      init.callee) && node.declarations[0].init.callee.name === "require" && import_babel3.types.isStringLiteral(node.declarations[0].init.arguments[0]) &&
+      node.declarations[0].init.arguments[0].value === fromImport
+    );
+    const hasRequireSpecifier = /* @__PURE__ */ __name((name) => import_babel3.types.isObjectPattern(requireDeclaration?.declarations[0].id) &&
+    requireDeclaration?.declarations[0].id.properties.find(
+      (specifier) => import_babel3.types.isObjectProperty(specifier) && import_babel3.types.isIdentifier(specifier.key) && specifier.key.name ===
+      name
+    ), "hasRequireSpecifier");
+    const hasDefaultRequireSpecifier = /* @__PURE__ */ __name((declaration, name) => declaration.declarations.length === 1 && import_babel3.types.
+    isVariableDeclarator(declaration.declarations[0]) && import_babel3.types.isIdentifier(declaration.declarations[0].id) && declaration.declarations[0].
+    id.name === name, "hasDefaultRequireSpecifier");
+    if (typeof importSpecifier === "string") {
+      const addDefaultRequireSpecifier = /* @__PURE__ */ __name(() => {
         this._ast.program.body.unshift(
-          o.types.variableDeclaration("const", [
-            o.types.variableDeclarator(
-              o.types.identifier(e),
-              o.types.callExpression(o.types.identifier("require"), [o.types.stringLiteral(i)])
+          import_babel3.types.variableDeclaration("const", [
+            import_babel3.types.variableDeclarator(
+              import_babel3.types.identifier(importSpecifier),
+              import_babel3.types.callExpression(import_babel3.types.identifier("require"), [import_babel3.types.stringLiteral(fromImport)])
             )
           ])
         );
       }, "addDefaultRequireSpecifier");
-      t && a(t, e) || n();
-    } else t ? e.forEach((n) => {
-      r(n) || t.declarations[0].id.properties.push(
-        o.types.objectProperty(o.types.identifier(n), o.types.identifier(n), void 0, !0)
+      if (requireDeclaration) {
+        if (!hasDefaultRequireSpecifier(requireDeclaration, importSpecifier)) {
+          addDefaultRequireSpecifier();
+        }
+      } else {
+        addDefaultRequireSpecifier();
+      }
+    } else if (requireDeclaration) {
+      importSpecifier.forEach((specifier) => {
+        if (!hasRequireSpecifier(specifier)) {
+          requireDeclaration.declarations[0].id.properties.push(
+            import_babel3.types.objectProperty(import_babel3.types.identifier(specifier), import_babel3.types.identifier(specifier), void 0,
+            true)
+          );
+        }
+      });
+    } else {
+      this._ast.program.body.unshift(
+        import_babel3.types.variableDeclaration("const", [
+          import_babel3.types.variableDeclarator(
+            import_babel3.types.objectPattern(
+              importSpecifier.map(
+                (specifier) => import_babel3.types.objectProperty(import_babel3.types.identifier(specifier), import_babel3.types.identifier(
+                specifier), void 0, true)
+              )
+            ),
+            import_babel3.types.callExpression(import_babel3.types.identifier("require"), [import_babel3.types.stringLiteral(fromImport)])
+          )
+        ])
       );
-    }) : this._ast.program.body.unshift(
-      o.types.variableDeclaration("const", [
-        o.types.variableDeclarator(
-          o.types.objectPattern(
-            e.map(
-              (n) => o.types.objectProperty(o.types.identifier(n), o.types.identifier(n), void 0, !0)
-            )
-          ),
-          o.types.callExpression(o.types.identifier("require"), [o.types.stringLiteral(i)])
-        )
-      ])
-    );
+    }
   }
   /**
    * Set import specifiers for a given import statement.
@@ -923,67 +1310,112 @@ s, "unwrap"), ue = /* @__PURE__ */ p((s, e) => {
    *   import will be set. Otherwise, an array of named imports will be set
    * @param fromImport - The module to import from
    */
-  setImport(e, i) {
-    let t = /* @__PURE__ */ p((l) => o.types.importSpecifier(o.types.identifier(l), o.types.identifier(l)), "getNewImportSpecifier"), r = /* @__PURE__ */ p(
-    (l, u) => l.specifiers.find(
-      (d) => o.types.isImportSpecifier(d) && o.types.isIdentifier(d.imported) && d.imported.name === u
-    ), "hasImportSpecifier"), a = /* @__PURE__ */ p((l, u) => l.specifiers.find((d) => o.types.isImportDefaultSpecifier(d)), "hasDefaultImpo\
-rtSpecifier"), n = this._ast.program.body.find(
-      (l) => o.types.isImportDeclaration(l) && l.source.value === i
-    );
-    typeof e == "string" ? n ? a(n, e) || n.specifiers.push(
-      o.types.importDefaultSpecifier(o.types.identifier(e))
-    ) : this._ast.program.body.unshift(
-      o.types.importDeclaration(
-        [o.types.importDefaultSpecifier(o.types.identifier(e))],
-        o.types.stringLiteral(i)
-      )
-    ) : n ? e.forEach((l) => {
-      r(n, l) || n.specifiers.push(t(l));
-    }) : this._ast.program.body.unshift(
-      o.types.importDeclaration(
-        e.map(
-          (l) => o.types.importSpecifier(o.types.identifier(l), o.types.identifier(l))
-        ),
-        o.types.stringLiteral(i)
-      )
+  setImport(importSpecifier, fromImport) {
+    const getNewImportSpecifier = /* @__PURE__ */ __name((specifier) => import_babel3.types.importSpecifier(import_babel3.types.identifier(specifier),
+    import_babel3.types.identifier(specifier)), "getNewImportSpecifier");
+    const hasImportSpecifier = /* @__PURE__ */ __name((declaration, name) => declaration.specifiers.find(
+      (specifier) => import_babel3.types.isImportSpecifier(specifier) && import_babel3.types.isIdentifier(specifier.imported) && specifier.imported.
+      name === name
+    ), "hasImportSpecifier");
+    const hasDefaultImportSpecifier = /* @__PURE__ */ __name((declaration, name) => declaration.specifiers.find((specifier) => import_babel3.types.
+    isImportDefaultSpecifier(specifier)), "hasDefaultImportSpecifier");
+    const importDeclaration = this._ast.program.body.find(
+      (node) => import_babel3.types.isImportDeclaration(node) && node.source.value === fromImport
     );
+    if (typeof importSpecifier === "string") {
+      if (importDeclaration) {
+        if (!hasDefaultImportSpecifier(importDeclaration, importSpecifier)) {
+          importDeclaration.specifiers.push(
+            import_babel3.types.importDefaultSpecifier(import_babel3.types.identifier(importSpecifier))
+          );
+        }
+      } else {
+        this._ast.program.body.unshift(
+          import_babel3.types.importDeclaration(
+            [import_babel3.types.importDefaultSpecifier(import_babel3.types.identifier(importSpecifier))],
+            import_babel3.types.stringLiteral(fromImport)
+          )
+        );
+      }
+    } else if (importDeclaration) {
+      importSpecifier.forEach((specifier) => {
+        if (!hasImportSpecifier(importDeclaration, specifier)) {
+          importDeclaration.specifiers.push(getNewImportSpecifier(specifier));
+        }
+      });
+    } else {
+      this._ast.program.body.unshift(
+        import_babel3.types.importDeclaration(
+          importSpecifier.map(
+            (specifier) => import_babel3.types.importSpecifier(import_babel3.types.identifier(specifier), import_babel3.types.identifier(specifier))
+          ),
+          import_babel3.types.stringLiteral(fromImport)
+        )
+      );
+    }
   }
-}, xe = /* @__PURE__ */ p((s, e) => {
-  let i = (0, o.babelParse)(s);
-  return new W(i, s, e);
-}, "loadConfig"), ye = /* @__PURE__ */ p((s) => be(s).code, "formatConfig"), be = /* @__PURE__ */ p((s, e = {}) => o.recast.print(s._ast, e),
-"printConfig"), Ze = /* @__PURE__ */ p(async (s) => {
-  let e = (await (0, z.readFile)(s, "utf-8")).toString();
-  return xe(e, s).parse();
-}, "readConfig"), et = /* @__PURE__ */ p(async (s, e) => {
-  let i = e || s.fileName;
-  if (!i)
+};
+var loadConfig = /* @__PURE__ */ __name((code, fileName) => {
+  const ast = (0, import_babel3.babelParse)(code);
+  return new ConfigFile(ast, code, fileName);
+}, "loadConfig");
+var formatConfig = /* @__PURE__ */ __name((config) => {
+  return printConfig(config).code;
+}, "formatConfig");
+var printConfig = /* @__PURE__ */ __name((config, options = {}) => {
+  return import_babel3.recast.print(config._ast, options);
+}, "printConfig");
+var readConfig = /* @__PURE__ */ __name(async (fileName) => {
+  const code = (await (0, import_promises2.readFile)(fileName, "utf-8")).toString();
+  return loadConfig(code, fileName).parse();
+}, "readConfig");
+var writeConfig = /* @__PURE__ */ __name(async (config, fileName) => {
+  const fname = fileName || config.fileName;
+  if (!fname) {
     throw new Error("Please specify a fileName for writeConfig");
-  await (0, z.writeFile)(i, ye(s));
+  }
+  await (0, import_promises2.writeFile)(fname, formatConfig(config));
 }, "writeConfig");
 
 // src/csf-tools/getStorySortParameter.ts
-var y = require("@storybook/core/babel"), Ee = M(C(), 1);
-var tt = console, H = /* @__PURE__ */ p((s, e) => {
-  let i;
-  return s.properties.forEach((t) => {
-    y.types.isIdentifier(t.key) && t.key.name === e && (i = t.value);
-  }), i;
-}, "getValue"), Y = /* @__PURE__ */ p((s) => {
-  let e = R(s);
-  if (y.types.isArrayExpression(e))
-    return e.elements.map((i) => Y(i));
-  if (y.types.isObjectExpression(e))
-    return e.properties.reduce((i, t) => (y.types.isIdentifier(t.key) && (i[t.key.name] = Y(t.value)), i), {});
-  if (y.types.isLiteral(e))
-    return e.value;
-  if (y.types.isIdentifier(e))
-    return N(e.name, !0);
-  throw new Error(`Unknown node type ${e.type}`);
-}, "parseValue"), N = /* @__PURE__ */ p((s, e) => {
-  let i = Ee.dedent`
-    Unexpected '${s}'. Parameter 'options.storySort' should be defined inline e.g.:
+var import_babel4 = require("@storybook/core/babel");
+var import_ts_dedent3 = __toESM(require_dist(), 1);
+var logger3 = console;
+var getValue = /* @__PURE__ */ __name((obj, key) => {
+  let value;
+  obj.properties.forEach((p) => {
+    if (import_babel4.types.isIdentifier(p.key) && p.key.name === key) {
+      value = p.value;
+    }
+  });
+  return value;
+}, "getValue");
+var parseValue = /* @__PURE__ */ __name((value) => {
+  const expr = stripTSModifiers(value);
+  if (import_babel4.types.isArrayExpression(expr)) {
+    return expr.elements.map((o) => {
+      return parseValue(o);
+    });
+  }
+  if (import_babel4.types.isObjectExpression(expr)) {
+    return expr.properties.reduce((acc, p) => {
+      if (import_babel4.types.isIdentifier(p.key)) {
+        acc[p.key.name] = parseValue(p.value);
+      }
+      return acc;
+    }, {});
+  }
+  if (import_babel4.types.isLiteral(expr)) {
+    return expr.value;
+  }
+  if (import_babel4.types.isIdentifier(expr)) {
+    return unsupported(expr.name, true);
+  }
+  throw new Error(`Unknown node type ${expr.type}`);
+}, "parseValue");
+var unsupported = /* @__PURE__ */ __name((unexpectedVar, isError) => {
+  const message = import_ts_dedent3.dedent`
+    Unexpected '${unexpectedVar}'. Parameter 'options.storySort' should be defined inline e.g.:
 
     export default {
       parameters: {
@@ -993,319 +1425,437 @@ var tt = console, H = /* @__PURE__ */ p((s, e) => {
       },
     };
   `;
-  if (e)
-    throw new Error(i);
-  tt.info(i);
-}, "unsupported"), R = /* @__PURE__ */ p((s) => y.types.isTSAsExpression(s) || y.types.isTSSatisfiesExpression(s) ? s.expression : s, "strip\
-TSModifiers"), he = /* @__PURE__ */ p((s) => {
-  let e = R(s);
-  if (y.types.isObjectExpression(e)) {
-    let i = H(e, "options");
-    if (i) {
-      if (y.types.isObjectExpression(i))
-        return H(i, "storySort");
-      N("options", !0);
+  if (isError) {
+    throw new Error(message);
+  } else {
+    logger3.info(message);
+  }
+}, "unsupported");
+var stripTSModifiers = /* @__PURE__ */ __name((expr) => import_babel4.types.isTSAsExpression(expr) || import_babel4.types.isTSSatisfiesExpression(
+expr) ? expr.expression : expr, "stripTSModifiers");
+var parseParameters = /* @__PURE__ */ __name((params) => {
+  const paramsObject = stripTSModifiers(params);
+  if (import_babel4.types.isObjectExpression(paramsObject)) {
+    const options = getValue(paramsObject, "options");
+    if (options) {
+      if (import_babel4.types.isObjectExpression(options)) {
+        return getValue(options, "storySort");
+      }
+      unsupported("options", true);
     }
   }
-}, "parseParameters"), rt = /* @__PURE__ */ p((s, e) => {
-  let i = R(s);
-  if (y.types.isObjectExpression(i)) {
-    let t = H(i, "parameters");
-    if (y.types.isIdentifier(t) && (t = O(t.name, e)), t)
-      return he(t);
-  } else
-    N("default", !0);
-}, "parseDefault"), it = /* @__PURE__ */ p((s) => {
-  if (!s.includes("storySort"))
-    return;
-  let e, i = (0, y.babelParse)(s);
-  if ((0, y.traverse)(i, {
+  return void 0;
+}, "parseParameters");
+var parseDefault = /* @__PURE__ */ __name((defaultExpr, program) => {
+  const defaultObj = stripTSModifiers(defaultExpr);
+  if (import_babel4.types.isObjectExpression(defaultObj)) {
+    let params = getValue(defaultObj, "parameters");
+    if (import_babel4.types.isIdentifier(params)) {
+      params = findVarInitialization(params.name, program);
+    }
+    if (params) {
+      return parseParameters(params);
+    }
+  } else {
+    unsupported("default", true);
+  }
+  return void 0;
+}, "parseDefault");
+var getStorySortParameter = /* @__PURE__ */ __name((previewCode) => {
+  if (!previewCode.includes("storySort")) {
+    return void 0;
+  }
+  let storySort;
+  const ast = (0, import_babel4.babelParse)(previewCode);
+  (0, import_babel4.traverse)(ast, {
     ExportNamedDeclaration: {
-      enter({ node: t }) {
-        y.types.isVariableDeclaration(t.declaration) ? t.declaration.declarations.forEach((r) => {
-          if (y.types.isVariableDeclarator(r) && y.types.isIdentifier(r.id)) {
-            let { name: a } = r.id;
-            if (a === "parameters" && r.init) {
-              let n = R(r.init);
-              e = he(n);
+      enter({ node }) {
+        if (import_babel4.types.isVariableDeclaration(node.declaration)) {
+          node.declaration.declarations.forEach((decl) => {
+            if (import_babel4.types.isVariableDeclarator(decl) && import_babel4.types.isIdentifier(decl.id)) {
+              const { name: exportName } = decl.id;
+              if (exportName === "parameters" && decl.init) {
+                const paramsObject = stripTSModifiers(decl.init);
+                storySort = parseParameters(paramsObject);
+              }
             }
-          }
-        }) : t.specifiers.forEach((r) => {
-          y.types.isIdentifier(r.exported) && r.exported.name === "parameters" && N("parameters", !1);
-        });
+          });
+        } else {
+          node.specifiers.forEach((spec) => {
+            if (import_babel4.types.isIdentifier(spec.exported) && spec.exported.name === "parameters") {
+              unsupported("parameters", false);
+            }
+          });
+        }
       }
     },
     ExportDefaultDeclaration: {
-      enter({ node: t }) {
-        let r = t.declaration;
-        y.types.isIdentifier(r) && (r = O(r.name, i.program)), r = R(r), y.types.isObjectExpression(r) ? e = rt(r, i.program) : N("default",
-        !1);
+      enter({ node }) {
+        let defaultObj = node.declaration;
+        if (import_babel4.types.isIdentifier(defaultObj)) {
+          defaultObj = findVarInitialization(defaultObj.name, ast.program);
+        }
+        defaultObj = stripTSModifiers(defaultObj);
+        if (import_babel4.types.isObjectExpression(defaultObj)) {
+          storySort = parseDefault(defaultObj, ast.program);
+        } else {
+          unsupported("default", false);
+        }
       }
     }
-  }), !!e) {
-    if (y.types.isArrowFunctionExpression(e)) {
-      let { code: t } = (0, y.generate)(e, {});
-      return (0, eval)(t);
-    }
-    if (y.types.isFunctionExpression(e)) {
-      let { code: t } = (0, y.generate)(e, {}), r = e.id?.name, a = `(a, b) => {
-      ${t};
-      return ${r}(a, b)
+  });
+  if (!storySort) {
+    return void 0;
+  }
+  if (import_babel4.types.isArrowFunctionExpression(storySort)) {
+    const { code: sortCode } = (0, import_babel4.generate)(storySort, {});
+    return (0, eval)(sortCode);
+  }
+  if (import_babel4.types.isFunctionExpression(storySort)) {
+    const { code: sortCode } = (0, import_babel4.generate)(storySort, {});
+    const functionName = storySort.id?.name;
+    const wrapper = `(a, b) => {
+      ${sortCode};
+      return ${functionName}(a, b)
     }`;
-      return (0, eval)(a);
-    }
-    return y.types.isLiteral(e) || y.types.isArrayExpression(e) || y.types.isObjectExpression(e) ? Y(e) : N("storySort", !0);
+    return (0, eval)(wrapper);
   }
+  if (import_babel4.types.isLiteral(storySort) || import_babel4.types.isArrayExpression(storySort) || import_babel4.types.isObjectExpression(
+  storySort)) {
+    return parseValue(storySort);
+  }
+  return unsupported("storySort", true);
 }, "getStorySortParameter");
 
 // src/csf-tools/enrichCsf.ts
-var m = require("@storybook/core/babel");
-var _e = /* @__PURE__ */ p((s, e, i, t) => {
-  let r = e.getStoryExport(i), a = !t?.disableSource && Oe(r), n = !t?.disableDescription && Z(e._storyStatements[i]), l = [], u = m.types.memberExpression(
-  m.types.identifier(i), m.types.identifier("parameters"));
-  l.push(m.types.spreadElement(u));
-  let d = m.types.optionalMemberExpression(
-    u,
-    m.types.identifier("docs"),
-    !1,
-    !0
-  ), x = [];
-  if (a) {
-    let g = m.types.optionalMemberExpression(
-      d,
-      m.types.identifier("source"),
-      !1,
-      !0
+var import_babel5 = require("@storybook/core/babel");
+var enrichCsfStory = /* @__PURE__ */ __name((csf, csfSource, key, options) => {
+  const storyExport = csfSource.getStoryExport(key);
+  const source = !options?.disableSource && extractSource(storyExport);
+  const description = !options?.disableDescription && extractDescription(csfSource._storyStatements[key]);
+  const parameters = [];
+  const originalParameters = import_babel5.types.memberExpression(import_babel5.types.identifier(key), import_babel5.types.identifier("param\
+eters"));
+  parameters.push(import_babel5.types.spreadElement(originalParameters));
+  const optionalDocs = import_babel5.types.optionalMemberExpression(
+    originalParameters,
+    import_babel5.types.identifier("docs"),
+    false,
+    true
+  );
+  const extraDocsParameters = [];
+  if (source) {
+    const optionalSource = import_babel5.types.optionalMemberExpression(
+      optionalDocs,
+      import_babel5.types.identifier("source"),
+      false,
+      true
     );
-    x.push(
-      m.types.objectProperty(
-        m.types.identifier("source"),
-        m.types.objectExpression([
-          m.types.objectProperty(m.types.identifier("originalSource"), m.types.stringLiteral(a)),
-          m.types.spreadElement(g)
+    extraDocsParameters.push(
+      import_babel5.types.objectProperty(
+        import_babel5.types.identifier("source"),
+        import_babel5.types.objectExpression([
+          import_babel5.types.objectProperty(import_babel5.types.identifier("originalSource"), import_babel5.types.stringLiteral(source)),
+          import_babel5.types.spreadElement(optionalSource)
         ])
       )
     );
   }
-  if (n) {
-    let g = m.types.optionalMemberExpression(
-      d,
-      m.types.identifier("description"),
-      !1,
-      !0
+  if (description) {
+    const optionalDescription = import_babel5.types.optionalMemberExpression(
+      optionalDocs,
+      import_babel5.types.identifier("description"),
+      false,
+      true
     );
-    x.push(
-      m.types.objectProperty(
-        m.types.identifier("description"),
-        m.types.objectExpression([
-          m.types.objectProperty(m.types.identifier("story"), m.types.stringLiteral(n)),
-          m.types.spreadElement(g)
+    extraDocsParameters.push(
+      import_babel5.types.objectProperty(
+        import_babel5.types.identifier("description"),
+        import_babel5.types.objectExpression([
+          import_babel5.types.objectProperty(import_babel5.types.identifier("story"), import_babel5.types.stringLiteral(description)),
+          import_babel5.types.spreadElement(optionalDescription)
         ])
       )
     );
   }
-  if (x.length > 0) {
-    l.push(
-      m.types.objectProperty(
-        m.types.identifier("docs"),
-        m.types.objectExpression([m.types.spreadElement(d), ...x])
+  if (extraDocsParameters.length > 0) {
+    parameters.push(
+      import_babel5.types.objectProperty(
+        import_babel5.types.identifier("docs"),
+        import_babel5.types.objectExpression([import_babel5.types.spreadElement(optionalDocs), ...extraDocsParameters])
       )
     );
-    let g = m.types.expressionStatement(
-      m.types.assignmentExpression("=", u, m.types.objectExpression(l))
+    const addParameter = import_babel5.types.expressionStatement(
+      import_babel5.types.assignmentExpression("=", originalParameters, import_babel5.types.objectExpression(parameters))
     );
-    s._ast.program.body.push(g);
+    csf._ast.program.body.push(addParameter);
   }
-}, "enrichCsfStory"), Se = /* @__PURE__ */ p((s, e, i) => {
-  if (!e.length) {
-    s.properties.find(
-      (u) => m.types.isObjectProperty(u) && m.types.isIdentifier(u.key) && u.key.name === "component"
-    ) || s.properties.unshift(i);
+}, "enrichCsfStory");
+var addComponentDescription = /* @__PURE__ */ __name((node, path, value) => {
+  if (!path.length) {
+    const hasExistingComponent = node.properties.find(
+      (p) => import_babel5.types.isObjectProperty(p) && import_babel5.types.isIdentifier(p.key) && p.key.name === "component"
+    );
+    if (!hasExistingComponent) {
+      node.properties.unshift(value);
+    }
     return;
   }
-  let [t, ...r] = e, a = s.properties.find(
-    (l) => m.types.isObjectProperty(l) && m.types.isIdentifier(l.key) && l.key.name === t && m.types.isObjectExpression(l.value)
-  ), n;
-  a ? n = a.value : (n = m.types.objectExpression([]), s.properties.push(m.types.objectProperty(m.types.identifier(t), n))), Se(n, r, i);
-}, "addComponentDescription"), je = /* @__PURE__ */ p((s, e, i) => {
-  let t = !i?.disableDescription && Z(e._metaStatement);
-  if (t) {
-    let r = s._metaNode;
-    r && m.types.isObjectExpression(r) && Se(
-      r,
-      ["parameters", "docs", "description"],
-      m.types.objectProperty(m.types.identifier("component"), m.types.stringLiteral(t))
-    );
+  const [first, ...rest] = path;
+  const existing = node.properties.find(
+    (p) => import_babel5.types.isObjectProperty(p) && import_babel5.types.isIdentifier(p.key) && p.key.name === first && import_babel5.types.
+    isObjectExpression(p.value)
+  );
+  let subNode;
+  if (existing) {
+    subNode = existing.value;
+  } else {
+    subNode = import_babel5.types.objectExpression([]);
+    node.properties.push(import_babel5.types.objectProperty(import_babel5.types.identifier(first), subNode));
+  }
+  addComponentDescription(subNode, rest, value);
+}, "addComponentDescription");
+var enrichCsfMeta = /* @__PURE__ */ __name((csf, csfSource, options) => {
+  const description = !options?.disableDescription && extractDescription(csfSource._metaStatement);
+  if (description) {
+    const metaNode = csf._metaNode;
+    if (metaNode && import_babel5.types.isObjectExpression(metaNode)) {
+      addComponentDescription(
+        metaNode,
+        ["parameters", "docs", "description"],
+        import_babel5.types.objectProperty(import_babel5.types.identifier("component"), import_babel5.types.stringLiteral(description))
+      );
+    }
   }
-}, "enrichCsfMeta"), st = /* @__PURE__ */ p((s, e, i) => {
-  je(s, e, i), Object.keys(s._storyExports).forEach((t) => {
-    _e(s, e, t, i);
+}, "enrichCsfMeta");
+var enrichCsf = /* @__PURE__ */ __name((csf, csfSource, options) => {
+  enrichCsfMeta(csf, csfSource, options);
+  Object.keys(csf._storyExports).forEach((key) => {
+    enrichCsfStory(csf, csfSource, key, options);
   });
-}, "enrichCsf"), Oe = /* @__PURE__ */ p((s) => {
-  let e = m.types.isVariableDeclarator(s) ? s.init : s, { code: i } = (0, m.generate)(e, {});
-  return i;
-}, "extractSource"), Z = /* @__PURE__ */ p((s) => s?.leadingComments ? s.leadingComments.map((i) => i.type === "CommentLine" || !i.value.startsWith(
-"*") ? null : i.value.split(`
-`).map((t) => t.replace(/^(\s+)?(\*+)?(\s)?/, "")).join(`
-`).trim()).filter(Boolean).join(`
-`) : "", "extractDescription");
+}, "enrichCsf");
+var extractSource = /* @__PURE__ */ __name((node) => {
+  const src = import_babel5.types.isVariableDeclarator(node) ? node.init : node;
+  const { code } = (0, import_babel5.generate)(src, {});
+  return code;
+}, "extractSource");
+var extractDescription = /* @__PURE__ */ __name((node) => {
+  if (!node?.leadingComments) {
+    return "";
+  }
+  const comments = node.leadingComments.map((comment) => {
+    if (comment.type === "CommentLine" || !comment.value.startsWith("*")) {
+      return null;
+    }
+    return comment.value.split("\n").map((line) => line.replace(/^(\s+)?(\*+)?(\s)?/, "")).join("\n").trim();
+  }).filter(Boolean);
+  return comments.join("\n");
+}, "extractDescription");
 
 // src/csf-tools/index.ts
-var Ne = require("@storybook/core/babel");
+var import_babel7 = require("@storybook/core/babel");
 
 // src/csf-tools/vitest-plugin/transformer.ts
-var f = require("@storybook/core/babel"), De = require("@storybook/core/common"), ve = require("@storybook/csf"), ee = M(C(), 1);
-var Pe = console, nt = /* @__PURE__ */ p((s, e) => {
-  let i = e?.include.length === 0 || e?.include.some((r) => s.includes(r)), t = e?.exclude.every((r) => !s.includes(r));
-  return i && t;
+var import_babel6 = require("@storybook/core/babel");
+var import_common = require("@storybook/core/common");
+var import_csf2 = require("@storybook/csf");
+var import_ts_dedent4 = __toESM(require_dist(), 1);
+var logger4 = console;
+var isValidTest = /* @__PURE__ */ __name((storyTags, tagsFilter) => {
+  const isIncluded = tagsFilter?.include.length === 0 || tagsFilter?.include.some((tag) => storyTags.includes(tag));
+  const isNotExcluded = tagsFilter?.exclude.every((tag) => !storyTags.includes(tag));
+  return isIncluded && isNotExcluded;
 }, "isValidTest");
-async function Ie({
-  code: s,
-  fileName: e,
-  configDir: i,
-  stories: t,
-  tagsFilter: r,
-  previewLevelTags: a = []
+async function vitestTransform({
+  code,
+  fileName,
+  configDir,
+  stories,
+  tagsFilter,
+  previewLevelTags = []
 }) {
-  if (!/\.stor(y|ies)\./.test(e))
-    return s;
-  let l = q(s, {
-    fileName: e,
-    transformInlineMeta: !0,
-    makeTitle: /* @__PURE__ */ p((E) => {
-      let j = (0, De.getStoryTitle)({
-        storyFilePath: e,
-        configDir: i,
-        stories: t,
-        userTitle: E
+  const isStoryFile = /\.stor(y|ies)\./.test(fileName);
+  if (!isStoryFile) {
+    return code;
+  }
+  const parsed = loadCsf(code, {
+    fileName,
+    transformInlineMeta: true,
+    makeTitle: /* @__PURE__ */ __name((title) => {
+      const result = (0, import_common.getStoryTitle)({
+        storyFilePath: fileName,
+        configDir,
+        stories,
+        userTitle: title
       }) || "unknown";
-      return j === "unknown" && Pe.warn(
-        ee.dedent`
-            [Storybook]: Could not calculate story title for "${e}".
-            Please make sure that this file matches the globs included in the "stories" field in your Storybook configuration at "${i}".
+      if (result === "unknown") {
+        logger4.warn(
+          import_ts_dedent4.dedent`
+            [Storybook]: Could not calculate story title for "${fileName}".
+            Please make sure that this file matches the globs included in the "stories" field in your Storybook configuration at "${configDir}".
           `
-      ), j;
+        );
+      }
+      return result;
     }, "makeTitle")
-  }).parse(), u = l._ast, d = l._metaVariableName, x = l._metaNode, g = x.properties.find(
-    (E) => f.types.isObjectProperty(E) && f.types.isIdentifier(E.key) && E.key.name === "title"
-  ), b = f.types.stringLiteral(l._meta?.title || "unknown");
-  if (g ? f.types.isObjectProperty(g) && (g.value = b) : x.properties.push(f.types.objectProperty(f.types.identifier("title"), b)), !x || !l.
-  _meta)
+  }).parse();
+  const ast = parsed._ast;
+  const metaExportName = parsed._metaVariableName;
+  const metaNode = parsed._metaNode;
+  const metaTitleProperty = metaNode.properties.find(
+    (prop) => import_babel6.types.isObjectProperty(prop) && import_babel6.types.isIdentifier(prop.key) && prop.key.name === "title"
+  );
+  const metaTitle = import_babel6.types.stringLiteral(parsed._meta?.title || "unknown");
+  if (!metaTitleProperty) {
+    metaNode.properties.push(import_babel6.types.objectProperty(import_babel6.types.identifier("title"), metaTitle));
+  } else if (import_babel6.types.isObjectProperty(metaTitleProperty)) {
+    metaTitleProperty.value = metaTitle;
+  }
+  if (!metaNode || !parsed._meta) {
     throw new Error(
-      `The Storybook vitest plugin could not detect the meta (default export) object in the story file. 
-
-Please make sure you have a default export with the meta object. If you are using a different export format that is not supported, please fi\
-le an issue with details about your use case.`
+      "The Storybook vitest plugin could not detect the meta (default export) object in the story file. \n\nPlease make sure you have a defaul\
+t export with the meta object. If you are using a different export format that is not supported, please file an issue with details about you\
+r use case."
     );
-  let h = {};
-  Object.keys(l._stories).map((E) => {
-    let j = (0, ve.combineTags)(
+  }
+  const validStories = {};
+  Object.keys(parsed._stories).map((key) => {
+    const finalTags = (0, import_csf2.combineTags)(
       "test",
       "dev",
-      ...a,
-      ...l.meta?.tags || [],
-      ...l._stories[E].tags || []
+      ...previewLevelTags,
+      ...parsed.meta?.tags || [],
+      ...parsed._stories[key].tags || []
     );
-    nt(j, r) && (h[E] = l._storyStatements[E]);
+    if (isValidTest(finalTags, tagsFilter)) {
+      validStories[key] = parsed._storyStatements[key];
+    }
   });
-  let _ = l._file.path.scope.generateUidIdentifier("test"), te = l._file.path.scope.generateUidIdentifier("describe");
-  if (Object.keys(h).length === 0) {
-    let E = f.types.expressionStatement(
-      f.types.callExpression(f.types.memberExpression(te, f.types.identifier("skip")), [
-        f.types.stringLiteral("No valid tests found")
+  const vitestTestId = parsed._file.path.scope.generateUidIdentifier("test");
+  const vitestDescribeId = parsed._file.path.scope.generateUidIdentifier("describe");
+  if (Object.keys(validStories).length === 0) {
+    const describeSkipBlock = import_babel6.types.expressionStatement(
+      import_babel6.types.callExpression(import_babel6.types.memberExpression(vitestDescribeId, import_babel6.types.identifier("skip")), [
+        import_babel6.types.stringLiteral("No valid tests found")
       ])
     );
-    u.program.body.push(E);
-    let j = [
-      f.types.importDeclaration(
+    ast.program.body.push(describeSkipBlock);
+    const imports = [
+      import_babel6.types.importDeclaration(
         [
-          f.types.importSpecifier(_, f.types.identifier("test")),
-          f.types.importSpecifier(te, f.types.identifier("describe"))
+          import_babel6.types.importSpecifier(vitestTestId, import_babel6.types.identifier("test")),
+          import_babel6.types.importSpecifier(vitestDescribeId, import_babel6.types.identifier("describe"))
         ],
-        f.types.stringLiteral("vitest")
+        import_babel6.types.stringLiteral("vitest")
       )
     ];
-    u.program.body.unshift(...j);
+    ast.program.body.unshift(...imports);
   } else {
-    let re = function() {
-      let S = l._file.path.scope.generateUidIdentifier("isRunningFromThisFile"), D = f.types.memberExpression(
-        f.types.callExpression(f.types.memberExpression(E, f.types.identifier("getState")), []),
-        f.types.identifier("testPath")
-      ), L = f.types.memberExpression(
-        f.types.memberExpression(f.types.identifier("globalThis"), f.types.identifier("__vitest_worker__")),
-        f.types.identifier("filepath")
-      ), Re = f.types.logicalExpression(
+    let getTestGuardDeclaration2 = function() {
+      const isRunningFromThisFileId2 = parsed._file.path.scope.generateUidIdentifier("isRunningFromThisFile");
+      const testPathProperty = import_babel6.types.memberExpression(
+        import_babel6.types.callExpression(import_babel6.types.memberExpression(vitestExpectId, import_babel6.types.identifier("getState")),
+        []),
+        import_babel6.types.identifier("testPath")
+      );
+      const filePathProperty = import_babel6.types.memberExpression(
+        import_babel6.types.memberExpression(import_babel6.types.identifier("globalThis"), import_babel6.types.identifier("__vitest_worker__")),
+        import_babel6.types.identifier("filepath")
+      );
+      const nullishCoalescingExpression = import_babel6.types.logicalExpression(
         "??",
         // TODO: switch order of testPathProperty and filePathProperty when the bug is fixed
         // https://github.com/vitest-dev/vitest/issues/6367 (or probably just use testPathProperty)
-        L,
-        D
-      ), Le = f.types.callExpression(
-        f.types.memberExpression(
-          f.types.memberExpression(
-            f.types.memberExpression(f.types.identifier("import"), f.types.identifier("meta")),
-            f.types.identifier("url")
+        filePathProperty,
+        testPathProperty
+      );
+      const includesCall = import_babel6.types.callExpression(
+        import_babel6.types.memberExpression(
+          import_babel6.types.memberExpression(
+            import_babel6.types.memberExpression(import_babel6.types.identifier("import"), import_babel6.types.identifier("meta")),
+            import_babel6.types.identifier("url")
           ),
-          f.types.identifier("includes")
+          import_babel6.types.identifier("includes")
         ),
-        [Re]
+        [nullishCoalescingExpression]
       );
-      return { isRunningFromThisFileDeclaration: f.types.variableDeclaration("const", [
-        f.types.variableDeclarator(S, Le)
-      ]), isRunningFromThisFileId: S };
+      const isRunningFromThisFileDeclaration2 = import_babel6.types.variableDeclaration("const", [
+        import_babel6.types.variableDeclarator(isRunningFromThisFileId2, includesCall)
+      ]);
+      return { isRunningFromThisFileDeclaration: isRunningFromThisFileDeclaration2, isRunningFromThisFileId: isRunningFromThisFileId2 };
     };
-    var at = re;
-    p(re, "getTestGuardDeclaration");
-    let E = l._file.path.scope.generateUidIdentifier("expect"), j = l._file.path.scope.generateUidIdentifier("testStory"), we = f.types.identifier(
-    JSON.stringify(r.skip)), { isRunningFromThisFileDeclaration: Fe, isRunningFromThisFileId: Ce } = re();
-    u.program.body.push(Fe);
-    let Te = /* @__PURE__ */ p(({
-      exportName: S,
-      node: D
+    var getTestGuardDeclaration = getTestGuardDeclaration2;
+    __name(getTestGuardDeclaration2, "getTestGuardDeclaration");
+    const vitestExpectId = parsed._file.path.scope.generateUidIdentifier("expect");
+    const testStoryId = parsed._file.path.scope.generateUidIdentifier("testStory");
+    const skipTagsId = import_babel6.types.identifier(JSON.stringify(tagsFilter.skip));
+    const { isRunningFromThisFileDeclaration, isRunningFromThisFileId } = getTestGuardDeclaration2();
+    ast.program.body.push(isRunningFromThisFileDeclaration);
+    const getTestStatementForStory = /* @__PURE__ */ __name(({
+      exportName,
+      node
     }) => {
-      let L = f.types.expressionStatement(
-        f.types.callExpression(_, [
-          f.types.stringLiteral(S),
-          f.types.callExpression(j, [
-            f.types.stringLiteral(S),
-            f.types.identifier(S),
-            f.types.identifier(d),
-            we
+      const testStoryCall = import_babel6.types.expressionStatement(
+        import_babel6.types.callExpression(vitestTestId, [
+          import_babel6.types.stringLiteral(exportName),
+          import_babel6.types.callExpression(testStoryId, [
+            import_babel6.types.stringLiteral(exportName),
+            import_babel6.types.identifier(exportName),
+            import_babel6.types.identifier(metaExportName),
+            skipTagsId
           ])
         ])
       );
-      return L.loc = D.loc, L;
-    }, "getTestStatementForStory"), ke = Object.entries(h).map(([S, D]) => {
-      if (D === null) {
-        Pe.warn(
-          ee.dedent`
-            [Storybook]: Could not transform "${S}" story into test at "${e}".
+      testStoryCall.loc = node.loc;
+      return testStoryCall;
+    }, "getTestStatementForStory");
+    const storyTestStatements = Object.entries(validStories).map(([exportName, node]) => {
+      if (node === null) {
+        logger4.warn(
+          import_ts_dedent4.dedent`
+            [Storybook]: Could not transform "${exportName}" story into test at "${fileName}".
             Please make sure to define stories in the same file and not re-export stories coming from other files".
           `
         );
         return;
       }
-      return Te({
-        exportName: S,
-        node: D
+      return getTestStatementForStory({
+        exportName,
+        node
       });
-    }).filter((S) => !!S), Ve = f.types.ifStatement(Ce, f.types.blockStatement(ke));
-    u.program.body.push(Ve);
-    let Ae = [
-      f.types.importDeclaration(
+    }).filter((st) => !!st);
+    const testBlock = import_babel6.types.ifStatement(isRunningFromThisFileId, import_babel6.types.blockStatement(storyTestStatements));
+    const describeBlock = import_babel6.types.expressionStatement(
+      import_babel6.types.callExpression(
+        vitestDescribeId,
+        [
+          import_babel6.types.stringLiteral("foo"),
+          import_babel6.types.arrowFunctionExpression(
+            [],
+            import_babel6.types.blockStatement([
+              testBlock
+            ])
+          )
+        ]
+      )
+    );
+    ast.program.body.push(describeBlock);
+    const imports = [
+      import_babel6.types.importDeclaration(
         [
-          f.types.importSpecifier(_, f.types.identifier("test")),
-          f.types.importSpecifier(E, f.types.identifier("expect"))
+          import_babel6.types.importSpecifier(vitestDescribeId, import_babel6.types.identifier("describe")),
+          import_babel6.types.importSpecifier(vitestTestId, import_babel6.types.identifier("test")),
+          import_babel6.types.importSpecifier(vitestExpectId, import_babel6.types.identifier("expect"))
         ],
-        f.types.stringLiteral("vitest")
+        import_babel6.types.stringLiteral("vitest")
       ),
-      f.types.importDeclaration(
-        [f.types.importSpecifier(j, f.types.identifier("testStory"))],
-        f.types.stringLiteral("@storybook/experimental-addon-test/internal/test-utils")
+      import_babel6.types.importDeclaration(
+        [import_babel6.types.importSpecifier(testStoryId, import_babel6.types.identifier("testStory"))],
+        import_babel6.types.stringLiteral("@storybook/experimental-addon-test/internal/test-utils")
       )
     ];
-    u.program.body.unshift(...Ae);
+    ast.program.body.unshift(...imports);
   }
-  return J(l, { sourceMaps: !0, sourceFileName: e }, s);
+  return formatCsf(parsed, { sourceMaps: true, sourceFileName: fileName }, code);
 }
-p(Ie, "vitestTransform");
+__name(vitestTransform, "vitestTransform");
diff --git a/dist/csf-tools/index.js b/dist/csf-tools/index.js
index 28cab854bd0072d8107db5509b8ea61437986677..e3030080276ccdff716b9923f762ceb3f3dd1a0d 100644
--- a/dist/csf-tools/index.js
+++ b/dist/csf-tools/index.js
@@ -4,182 +4,246 @@ import { dirname as ESM_COMPAT_dirname } from 'node:path';
 const __filename = ESM_COMPAT_fileURLToPath(import.meta.url);
 const __dirname = ESM_COMPAT_dirname(__filename);
 const require = ESM_COMPAT_Module.createRequire(import.meta.url);
-var we = Object.create;
-var M = Object.defineProperty;
-var Fe = Object.getOwnPropertyDescriptor;
-var Ce = Object.getOwnPropertyNames;
-var Te = Object.getPrototypeOf, ke = Object.prototype.hasOwnProperty;
-var p = (s, e) => M(s, "name", { value: e, configurable: !0 });
-var Ve = (s, e) => () => (e || s((e = { exports: {} }).exports, e), e.exports);
-var Ae = (s, e, i, t) => {
-  if (e && typeof e == "object" || typeof e == "function")
-    for (let r of Ce(e))
-      !ke.call(s, r) && r !== i && M(s, r, { get: () => e[r], enumerable: !(t = Fe(e, r)) || t.enumerable });
-  return s;
+var __create = Object.create;
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __getOwnPropNames = Object.getOwnPropertyNames;
+var __getProtoOf = Object.getPrototypeOf;
+var __hasOwnProp = Object.prototype.hasOwnProperty;
+var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
+var __commonJS = (cb, mod) => function __require() {
+  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
 };
-var A = (s, e, i) => (i = s != null ? we(Te(s)) : {}, Ae(
+var __copyProps = (to, from, except, desc) => {
+  if (from && typeof from === "object" || typeof from === "function") {
+    for (let key of __getOwnPropNames(from))
+      if (!__hasOwnProp.call(to, key) && key !== except)
+        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+  }
+  return to;
+};
+var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
   // If the importer is in node compatibility mode or this is not an ESM
   // file that has been converted to a CommonJS file using a Babel-
   // compatible transform (i.e. "__esModule" has not been set), then set
   // "default" to the CommonJS "module.exports" for node compatibility.
-  e || !s || !s.__esModule ? M(i, "default", { value: s, enumerable: !0 }) : i,
-  s
+  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
+  mod
 ));
 
 // ../node_modules/ts-dedent/dist/index.js
-var N = Ve((I) => {
-  "use strict";
-  Object.defineProperty(I, "__esModule", { value: !0 });
-  I.dedent = void 0;
-  function Y(s) {
-    for (var e = [], i = 1; i < arguments.length; i++)
-      e[i - 1] = arguments[i];
-    var t = Array.from(typeof s == "string" ? [s] : s);
-    t[t.length - 1] = t[t.length - 1].replace(/\r?\n([\t ]*)$/, "");
-    var r = t.reduce(function(l, u) {
-      var d = u.match(/\n([\t ]+|(?!\s).)/g);
-      return d ? l.concat(d.map(function(x) {
-        var g, b;
-        return (b = (g = x.match(/[\t ]/g)) === null || g === void 0 ? void 0 : g.length) !== null && b !== void 0 ? b : 0;
-      })) : l;
-    }, []);
-    if (r.length) {
-      var a = new RegExp(`
-[	 ]{` + Math.min.apply(Math, r) + "}", "g");
-      t = t.map(function(l) {
-        return l.replace(a, `
-`);
+var require_dist = __commonJS({
+  "../node_modules/ts-dedent/dist/index.js"(exports) {
+    "use strict";
+    Object.defineProperty(exports, "__esModule", { value: true });
+    exports.dedent = void 0;
+    function dedent5(templ) {
+      var values = [];
+      for (var _i = 1; _i < arguments.length; _i++) {
+        values[_i - 1] = arguments[_i];
+      }
+      var strings = Array.from(typeof templ === "string" ? [templ] : templ);
+      strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
+      var indentLengths = strings.reduce(function(arr, str) {
+        var matches = str.match(/\n([\t ]+|(?!\s).)/g);
+        if (matches) {
+          return arr.concat(matches.map(function(match) {
+            var _a, _b;
+            return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
+          }));
+        }
+        return arr;
+      }, []);
+      if (indentLengths.length) {
+        var pattern_1 = new RegExp("\n[	 ]{" + Math.min.apply(Math, indentLengths) + "}", "g");
+        strings = strings.map(function(str) {
+          return str.replace(pattern_1, "\n");
+        });
+      }
+      strings[0] = strings[0].replace(/^\r?\n/, "");
+      var string = strings[0];
+      values.forEach(function(value, i) {
+        var endentations = string.match(/(?:^|\n)( *)$/);
+        var endentation = endentations ? endentations[1] : "";
+        var indentedValue = value;
+        if (typeof value === "string" && value.includes("\n")) {
+          indentedValue = String(value).split("\n").map(function(str, i2) {
+            return i2 === 0 ? str : "" + endentation + str;
+          }).join("\n");
+        }
+        string += indentedValue + strings[i + 1];
       });
+      return string;
     }
-    t[0] = t[0].replace(/^\r?\n/, "");
-    var n = t[0];
-    return e.forEach(function(l, u) {
-      var d = n.match(/(?:^|\n)( *)$/), x = d ? d[1] : "", g = l;
-      typeof l == "string" && l.includes(`
-`) && (g = String(l).split(`
-`).map(function(b, h) {
-        return h === 0 ? b : "" + x + b;
-      }).join(`
-`)), n += g + t[u + 1];
-    }), n;
-  }
-  p(Y, "dedent");
-  I.dedent = Y;
-  I.default = Y;
+    __name(dedent5, "dedent");
+    exports.dedent = dedent5;
+    exports.default = dedent5;
+  }
 });
 
 // src/csf-tools/CsfFile.ts
-var F = A(N(), 1);
-import { readFile as Re, writeFile as Le } from "node:fs/promises";
+var import_ts_dedent = __toESM(require_dist(), 1);
+import { readFile, writeFile } from "node:fs/promises";
 import {
-  BabelFileClass as Me,
-  babelParse as ne,
-  generate as $e,
-  recast as oe,
-  types as c,
-  traverse as Ue
+  BabelFileClass,
+  babelParse,
+  generate,
+  recast,
+  types as t2,
+  traverse
 } from "@storybook/core/babel";
-import { isExportStory as Z, storyNameFromExport as ee, toId as qe } from "@storybook/csf";
+import { isExportStory, storyNameFromExport, toId } from "@storybook/csf";
 
 // src/csf-tools/findVarInitialization.ts
-import { types as w } from "@storybook/core/babel";
-var O = /* @__PURE__ */ p((s, e) => {
-  let i = null, t = null;
-  return e.body.find((r) => (w.isVariableDeclaration(r) ? t = r.declarations : w.isExportNamedDeclaration(r) && w.isVariableDeclaration(r.declaration) &&
-  (t = r.declaration.declarations), t && t.find((a) => w.isVariableDeclarator(a) && w.isIdentifier(a.id) && a.id.name === s ? (i = a.init, !0) :
-  !1))), i;
+import { types as t } from "@storybook/core/babel";
+var findVarInitialization = /* @__PURE__ */ __name((identifier, program) => {
+  let init = null;
+  let declarations = null;
+  program.body.find((node) => {
+    if (t.isVariableDeclaration(node)) {
+      declarations = node.declarations;
+    } else if (t.isExportNamedDeclaration(node) && t.isVariableDeclaration(node.declaration)) {
+      declarations = node.declaration.declarations;
+    }
+    return declarations && declarations.find((decl) => {
+      if (t.isVariableDeclarator(decl) && t.isIdentifier(decl.id) && decl.id.name === identifier) {
+        init = decl.init;
+        return true;
+      }
+      return false;
+    });
+  });
+  return init;
 }, "findVarInitialization");
 
 // src/csf-tools/CsfFile.ts
-var te = console;
-function Be(s) {
-  if (c.isArrayExpression(s))
-    return s.elements.map((e) => {
-      if (c.isStringLiteral(e))
+var logger = console;
+function parseIncludeExclude(prop) {
+  if (t2.isArrayExpression(prop)) {
+    return prop.elements.map((e) => {
+      if (t2.isStringLiteral(e)) {
         return e.value;
+      }
       throw new Error(`Expected string literal: ${e}`);
     });
-  if (c.isStringLiteral(s))
-    return new RegExp(s.value);
-  if (c.isRegExpLiteral(s))
-    return new RegExp(s.pattern, s.flags);
-  throw new Error(`Unknown include/exclude: ${s}`);
+  }
+  if (t2.isStringLiteral(prop)) {
+    return new RegExp(prop.value);
+  }
+  if (t2.isRegExpLiteral(prop)) {
+    return new RegExp(prop.pattern, prop.flags);
+  }
+  throw new Error(`Unknown include/exclude: ${prop}`);
 }
-p(Be, "parseIncludeExclude");
-function re(s) {
-  if (!c.isArrayExpression(s))
+__name(parseIncludeExclude, "parseIncludeExclude");
+function parseTags(prop) {
+  if (!t2.isArrayExpression(prop)) {
     throw new Error("CSF: Expected tags array");
-  return s.elements.map((e) => {
-    if (c.isStringLiteral(e))
+  }
+  return prop.elements.map((e) => {
+    if (t2.isStringLiteral(e)) {
       return e.value;
-    throw new Error("CSF: Expected tag to be string literal");
+    }
+    throw new Error(`CSF: Expected tag to be string literal`);
   });
 }
-p(re, "parseTags");
-var $ = /* @__PURE__ */ p((s, e) => {
-  let { line: i, column: t } = s.loc?.start || {};
-  return `${e || ""} (line ${i}, col ${t})`.trim();
-}, "formatLocation"), We = /* @__PURE__ */ p((s) => Je.test(s), "isModuleMock"), ie = /* @__PURE__ */ p((s, e, i) => {
-  let t = s;
-  if (c.isCallExpression(s)) {
-    let { callee: r, arguments: a } = s;
-    if (c.isProgram(e) && c.isMemberExpression(r) && c.isIdentifier(r.object) && c.isIdentifier(r.property) && r.property.name === "bind" &&
-    (a.length === 0 || a.length === 1 && c.isObjectExpression(a[0]) && a[0].properties.length === 0)) {
-      let n = r.object.name, l = O(n, e);
-      l && (i._templates[n] = l, t = l);
+__name(parseTags, "parseTags");
+var formatLocation = /* @__PURE__ */ __name((node, fileName) => {
+  const { line, column } = node.loc?.start || {};
+  return `${fileName || ""} (line ${line}, col ${column})`.trim();
+}, "formatLocation");
+var isModuleMock = /* @__PURE__ */ __name((importPath) => MODULE_MOCK_REGEX.test(importPath), "isModuleMock");
+var isArgsStory = /* @__PURE__ */ __name((init, parent, csf) => {
+  let storyFn = init;
+  if (t2.isCallExpression(init)) {
+    const { callee, arguments: bindArguments } = init;
+    if (t2.isProgram(parent) && t2.isMemberExpression(callee) && t2.isIdentifier(callee.object) && t2.isIdentifier(callee.property) && callee.
+    property.name === "bind" && (bindArguments.length === 0 || bindArguments.length === 1 && t2.isObjectExpression(bindArguments[0]) && bindArguments[0].
+    properties.length === 0)) {
+      const boundIdentifier = callee.object.name;
+      const template = findVarInitialization(boundIdentifier, parent);
+      if (template) {
+        csf._templates[boundIdentifier] = template;
+        storyFn = template;
+      }
     }
   }
-  return c.isArrowFunctionExpression(t) || c.isFunctionDeclaration(t) ? t.params.length > 0 : !1;
-}, "isArgsStory"), ze = /* @__PURE__ */ p((s) => {
-  if (c.isArrayExpression(s))
-    return s.elements.map((e) => {
-      if (c.isStringLiteral(e))
-        return e.value;
-      throw new Error(`Expected string literal named export: ${e}`);
+  if (t2.isArrowFunctionExpression(storyFn)) {
+    return storyFn.params.length > 0;
+  }
+  if (t2.isFunctionDeclaration(storyFn)) {
+    return storyFn.params.length > 0;
+  }
+  return false;
+}, "isArgsStory");
+var parseExportsOrder = /* @__PURE__ */ __name((init) => {
+  if (t2.isArrayExpression(init)) {
+    return init.elements.map((item) => {
+      if (t2.isStringLiteral(item)) {
+        return item.value;
+      }
+      throw new Error(`Expected string literal named export: ${item}`);
     });
-  throw new Error(`Expected array of string literals: ${s}`);
-}, "parseExportsOrder"), se = /* @__PURE__ */ p((s, e) => e.reduce(
-  (i, t) => {
-    let r = s[t];
-    return r && (i[t] = r), i;
-  },
-  {}
-), "sortExports"), Ge = /* @__PURE__ */ p((s) => {
-  if (c.isArrowFunctionExpression(s) || c.isFunctionDeclaration(s)) {
-    let e = s.params;
-    if (e.length >= 1) {
-      let [i] = e;
-      if (c.isObjectPattern(i))
-        return !!i.properties.find((t) => {
-          if (c.isObjectProperty(t) && c.isIdentifier(t.key))
-            return t.key.name === "mount";
+  }
+  throw new Error(`Expected array of string literals: ${init}`);
+}, "parseExportsOrder");
+var sortExports = /* @__PURE__ */ __name((exportByName, order) => {
+  return order.reduce(
+    (acc, name) => {
+      const namedExport = exportByName[name];
+      if (namedExport) {
+        acc[name] = namedExport;
+      }
+      return acc;
+    },
+    {}
+  );
+}, "sortExports");
+var hasMount = /* @__PURE__ */ __name((play) => {
+  if (t2.isArrowFunctionExpression(play) || t2.isFunctionDeclaration(play)) {
+    const params = play.params;
+    if (params.length >= 1) {
+      const [arg] = params;
+      if (t2.isObjectPattern(arg)) {
+        return !!arg.properties.find((prop) => {
+          if (t2.isObjectProperty(prop) && t2.isIdentifier(prop.key)) {
+            return prop.key.name === "mount";
+          }
         });
+      }
     }
   }
-  return !1;
-}, "hasMount"), Je = /^[.\/#].*\.mock($|\.[^.]*$)/i, R = class extends Error {
+  return false;
+}, "hasMount");
+var MODULE_MOCK_REGEX = /^[.\/#].*\.mock($|\.[^.]*$)/i;
+var NoMetaError = class extends Error {
   static {
-    p(this, "NoMetaError");
+    __name(this, "NoMetaError");
   }
-  constructor(e, i, t) {
-    super(F.dedent`
-      CSF: ${e} ${$(i, t)}
+  constructor(message, ast, fileName) {
+    super(import_ts_dedent.dedent`
+      CSF: ${message} ${formatLocation(ast, fileName)}
 
       More info: https://storybook.js.org/docs/react/writing-stories#default-export
-    `), this.name = this.constructor.name;
+    `);
+    this.name = this.constructor.name;
   }
-}, U = class {
-  constructor(e, i, t) {
+};
+var CsfFile = class {
+  constructor(ast, options, file) {
     this._stories = {};
     this._metaAnnotations = {};
     this._storyExports = {};
     this._storyStatements = {};
     this._storyAnnotations = {};
     this._templates = {};
-    this._ast = e, this._file = t, this._options = i, this.imports = [];
+    this._ast = ast;
+    this._file = file;
+    this._options = options;
+    this.imports = [];
   }
   static {
-    p(this, "CsfFile");
+    __name(this, "CsfFile");
   }
   /** @deprecated Use `_options.fileName` instead */
   get _fileName() {
@@ -189,246 +253,350 @@ var $ = /* @__PURE__ */ p((s, e) => {
   get _makeTitle() {
     return this._options.makeTitle;
   }
-  _parseTitle(e) {
-    let i = c.isIdentifier(e) ? O(e.name, this._ast.program) : e;
-    if (c.isStringLiteral(i))
-      return i.value;
-    if (c.isTSSatisfiesExpression(i) && c.isStringLiteral(i.expression))
-      return i.expression.value;
-    throw new Error(F.dedent`
-      CSF: unexpected dynamic title ${$(i, this._options.fileName)}
+  _parseTitle(value) {
+    const node = t2.isIdentifier(value) ? findVarInitialization(value.name, this._ast.program) : value;
+    if (t2.isStringLiteral(node)) {
+      return node.value;
+    }
+    if (t2.isTSSatisfiesExpression(node) && t2.isStringLiteral(node.expression)) {
+      return node.expression.value;
+    }
+    throw new Error(import_ts_dedent.dedent`
+      CSF: unexpected dynamic title ${formatLocation(node, this._options.fileName)}
 
       More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#string-literal-titles
     `);
   }
-  _parseMeta(e, i) {
-    let t = {};
-    e.properties.forEach((r) => {
-      if (c.isIdentifier(r.key)) {
-        if (this._metaAnnotations[r.key.name] = r.value, r.key.name === "title")
-          t.title = this._parseTitle(r.value);
-        else if (["includeStories", "excludeStories"].includes(r.key.name))
-          t[r.key.name] = Be(r.value);
-        else if (r.key.name === "component") {
-          let a = r.value;
-          if (c.isIdentifier(a)) {
-            let l = a.name, u = i.body.find(
-              (d) => c.isImportDeclaration(d) && d.specifiers.find((x) => x.local.name === l)
+  _parseMeta(declaration, program) {
+    const meta = {};
+    declaration.properties.forEach((p) => {
+      if (t2.isIdentifier(p.key)) {
+        this._metaAnnotations[p.key.name] = p.value;
+        if (p.key.name === "title") {
+          meta.title = this._parseTitle(p.value);
+        } else if (["includeStories", "excludeStories"].includes(p.key.name)) {
+          meta[p.key.name] = parseIncludeExclude(p.value);
+        } else if (p.key.name === "component") {
+          const n = p.value;
+          if (t2.isIdentifier(n)) {
+            const id = n.name;
+            const importStmt = program.body.find(
+              (stmt) => t2.isImportDeclaration(stmt) && stmt.specifiers.find((spec) => spec.local.name === id)
             );
-            if (u) {
-              let { source: d } = u;
-              c.isStringLiteral(d) && (this._rawComponentPath = d.value);
+            if (importStmt) {
+              const { source } = importStmt;
+              if (t2.isStringLiteral(source)) {
+                this._rawComponentPath = source.value;
+              }
             }
           }
-          let { code: n } = oe.print(r.value, {});
-          t.component = n;
-        } else if (r.key.name === "tags") {
-          let a = r.value;
-          c.isIdentifier(a) && (a = O(a.name, this._ast.program)), t.tags = re(a);
-        } else if (r.key.name === "id")
-          if (c.isStringLiteral(r.value))
-            t.id = r.value.value;
-          else
-            throw new Error(`Unexpected component id: ${r.value}`);
+          const { code } = recast.print(p.value, {});
+          meta.component = code;
+        } else if (p.key.name === "tags") {
+          let node = p.value;
+          if (t2.isIdentifier(node)) {
+            node = findVarInitialization(node.name, this._ast.program);
+          }
+          meta.tags = parseTags(node);
+        } else if (p.key.name === "id") {
+          if (t2.isStringLiteral(p.value)) {
+            meta.id = p.value.value;
+          } else {
+            throw new Error(`Unexpected component id: ${p.value}`);
+          }
+        }
       }
-    }), this._meta = t;
-  }
-  getStoryExport(e) {
-    let i = this._storyExports[e];
-    if (i = c.isVariableDeclarator(i) ? i.init : i, c.isCallExpression(i)) {
-      let { callee: t, arguments: r } = i;
-      if (c.isMemberExpression(t) && c.isIdentifier(t.object) && c.isIdentifier(t.property) && t.property.name === "bind" && (r.length === 0 ||
-      r.length === 1 && c.isObjectExpression(r[0]) && r[0].properties.length === 0)) {
-        let { name: a } = t.object;
-        i = this._templates[a];
+    });
+    this._meta = meta;
+  }
+  getStoryExport(key) {
+    let node = this._storyExports[key];
+    node = t2.isVariableDeclarator(node) ? node.init : node;
+    if (t2.isCallExpression(node)) {
+      const { callee, arguments: bindArguments } = node;
+      if (t2.isMemberExpression(callee) && t2.isIdentifier(callee.object) && t2.isIdentifier(callee.property) && callee.property.name === "b\
+ind" && (bindArguments.length === 0 || bindArguments.length === 1 && t2.isObjectExpression(bindArguments[0]) && bindArguments[0].properties.
+      length === 0)) {
+        const { name } = callee.object;
+        node = this._templates[name];
       }
     }
-    return i;
+    return node;
   }
   parse() {
-    let e = this;
-    if (Ue(this._ast, {
+    const self = this;
+    traverse(this._ast, {
       ExportDefaultDeclaration: {
-        enter(t) {
-          let { node: r, parent: a } = t, n = c.isIdentifier(r.declaration) && c.isProgram(a);
-          if (e._options.transformInlineMeta && !n && c.isExpression(r.declaration)) {
-            let d = t.scope.generateUidIdentifier("meta");
-            e._metaVariableName = d.name;
-            let x = [
-              c.variableDeclaration("const", [c.variableDeclarator(d, r.declaration)]),
-              c.exportDefaultDeclaration(d)
+        enter(path) {
+          const { node, parent } = path;
+          const isVariableReference = t2.isIdentifier(node.declaration) && t2.isProgram(parent);
+          if (self._options.transformInlineMeta && !isVariableReference && t2.isExpression(node.declaration)) {
+            const metaId = path.scope.generateUidIdentifier("meta");
+            self._metaVariableName = metaId.name;
+            const nodes = [
+              t2.variableDeclaration("const", [t2.variableDeclarator(metaId, node.declaration)]),
+              t2.exportDefaultDeclaration(metaId)
             ];
-            x.forEach((g) => g.loc = t.node.loc), t.replaceWithMultiple(x);
+            nodes.forEach((_node) => _node.loc = path.node.loc);
+            path.replaceWithMultiple(nodes);
           }
-          let l, u;
-          if (n) {
-            let d = r.declaration.name;
-            e._metaVariableName = d;
-            let x = /* @__PURE__ */ p((g) => c.isIdentifier(g.id) && g.id.name === d, "isVariableDeclarator");
-            e._metaStatement = e._ast.program.body.find(
-              (g) => c.isVariableDeclaration(g) && g.declarations.find(x)
-            ), u = (e?._metaStatement?.declarations || []).find(
-              x
+          let metaNode;
+          let decl;
+          if (isVariableReference) {
+            const variableName = node.declaration.name;
+            self._metaVariableName = variableName;
+            const isVariableDeclarator = /* @__PURE__ */ __name((declaration) => t2.isIdentifier(declaration.id) && declaration.id.name === variableName,
+            "isVariableDeclarator");
+            self._metaStatement = self._ast.program.body.find(
+              (topLevelNode) => t2.isVariableDeclaration(topLevelNode) && topLevelNode.declarations.find(isVariableDeclarator)
+            );
+            decl = (self?._metaStatement?.declarations || []).find(
+              isVariableDeclarator
             )?.init;
-          } else
-            e._metaStatement = r, u = r.declaration;
-          if (c.isObjectExpression(u) ? l = u : (
+          } else {
+            self._metaStatement = node;
+            decl = node.declaration;
+          }
+          if (t2.isObjectExpression(decl)) {
+            metaNode = decl;
+          } else if (
             // export default { ... } as Meta<...>
-            (c.isTSAsExpression(u) || c.isTSSatisfiesExpression(u)) && c.isObjectExpression(u.expression) && (l = u.expression)
-          ), !e._meta && l && c.isProgram(a) && (e._metaNode = l, e._parseMeta(l, a)), e._metaStatement && !e._metaNode)
-            throw new R(
+            (t2.isTSAsExpression(decl) || t2.isTSSatisfiesExpression(decl)) && t2.isObjectExpression(decl.expression)
+          ) {
+            metaNode = decl.expression;
+          }
+          if (!self._meta && metaNode && t2.isProgram(parent)) {
+            self._metaNode = metaNode;
+            self._parseMeta(metaNode, parent);
+          }
+          if (self._metaStatement && !self._metaNode) {
+            throw new NoMetaError(
               "default export must be an object",
-              e._metaStatement,
-              e._options.fileName
+              self._metaStatement,
+              self._options.fileName
             );
+          }
         }
       },
       ExportNamedDeclaration: {
-        enter({ node: t, parent: r }) {
-          let a;
-          c.isVariableDeclaration(t.declaration) ? a = t.declaration.declarations.filter((n) => c.isVariableDeclarator(n)) : c.isFunctionDeclaration(
-          t.declaration) && (a = [t.declaration]), a ? a.forEach((n) => {
-            if (c.isIdentifier(n.id)) {
-              let { name: l } = n.id;
-              if (l === "__namedExportsOrder" && c.isVariableDeclarator(n)) {
-                e._namedExportsOrder = ze(n.init);
-                return;
-              }
-              e._storyExports[l] = n, e._storyStatements[l] = t;
-              let u = ee(l);
-              e._storyAnnotations[l] ? te.warn(
-                `Unexpected annotations for "${l}" before story declaration`
-              ) : e._storyAnnotations[l] = {};
-              let d;
-              c.isVariableDeclarator(n) ? d = c.isTSAsExpression(n.init) || c.isTSSatisfiesExpression(n.init) ? n.init.expression : n.init :
-              d = n;
-              let x = {};
-              c.isObjectExpression(d) ? (x.__isArgsStory = !0, d.properties.forEach((g) => {
-                if (c.isIdentifier(g.key)) {
-                  if (g.key.name === "render")
-                    x.__isArgsStory = ie(
-                      g.value,
-                      r,
-                      e
-                    );
-                  else if (g.key.name === "name" && c.isStringLiteral(g.value))
-                    u = g.value.value;
-                  else if (g.key.name === "storyName" && c.isStringLiteral(g.value))
-                    te.warn(
-                      `Unexpected usage of "storyName" in "${l}". Please use "name" instead.`
-                    );
-                  else if (g.key.name === "parameters" && c.isObjectExpression(g.value)) {
-                    let b = g.value.properties.find(
-                      (h) => c.isObjectProperty(h) && c.isIdentifier(h.key) && h.key.name === "__id"
-                    );
-                    b && (x.__id = b.value.value);
-                  }
-                  e._storyAnnotations[l][g.key.name] = g.value;
+        enter({ node, parent }) {
+          let declarations;
+          if (t2.isVariableDeclaration(node.declaration)) {
+            declarations = node.declaration.declarations.filter((d) => t2.isVariableDeclarator(d));
+          } else if (t2.isFunctionDeclaration(node.declaration)) {
+            declarations = [node.declaration];
+          }
+          if (declarations) {
+            declarations.forEach((decl) => {
+              if (t2.isIdentifier(decl.id)) {
+                const { name: exportName } = decl.id;
+                if (exportName === "__namedExportsOrder" && t2.isVariableDeclarator(decl)) {
+                  self._namedExportsOrder = parseExportsOrder(decl.init);
+                  return;
                 }
-              })) : x.__isArgsStory = ie(d, r, e), e._stories[l] = {
-                id: "FIXME",
-                name: u,
-                parameters: x,
-                __stats: {}
-              };
-            }
-          }) : t.specifiers.length > 0 && t.specifiers.forEach((n) => {
-            if (c.isExportSpecifier(n) && c.isIdentifier(n.exported)) {
-              let { name: l } = n.exported, u = c.isProgram(r) ? O(n.local.name, r) : n.local;
-              if (l === "default") {
-                let d;
-                c.isObjectExpression(u) ? d = u : (
-                  // export default { ... } as Meta<...>
-                  c.isTSAsExpression(u) && c.isObjectExpression(u.expression) && (d = u.expression)
-                ), !e._meta && d && c.isProgram(r) && e._parseMeta(d, r);
-              } else
-                e._storyAnnotations[l] = {}, e._storyStatements[l] = u, e._stories[l] = {
+                self._storyExports[exportName] = decl;
+                self._storyStatements[exportName] = node;
+                let name = storyNameFromExport(exportName);
+                if (self._storyAnnotations[exportName]) {
+                  logger.warn(
+                    `Unexpected annotations for "${exportName}" before story declaration`
+                  );
+                } else {
+                  self._storyAnnotations[exportName] = {};
+                }
+                let storyNode;
+                if (t2.isVariableDeclarator(decl)) {
+                  storyNode = t2.isTSAsExpression(decl.init) || t2.isTSSatisfiesExpression(decl.init) ? decl.init.expression : decl.init;
+                } else {
+                  storyNode = decl;
+                }
+                const parameters = {};
+                if (t2.isObjectExpression(storyNode)) {
+                  parameters.__isArgsStory = true;
+                  storyNode.properties.forEach((p) => {
+                    if (t2.isIdentifier(p.key)) {
+                      if (p.key.name === "render") {
+                        parameters.__isArgsStory = isArgsStory(
+                          p.value,
+                          parent,
+                          self
+                        );
+                      } else if (p.key.name === "name" && t2.isStringLiteral(p.value)) {
+                        name = p.value.value;
+                      } else if (p.key.name === "storyName" && t2.isStringLiteral(p.value)) {
+                        logger.warn(
+                          `Unexpected usage of "storyName" in "${exportName}". Please use "name" instead.`
+                        );
+                      } else if (p.key.name === "parameters" && t2.isObjectExpression(p.value)) {
+                        const idProperty = p.value.properties.find(
+                          (property) => t2.isObjectProperty(property) && t2.isIdentifier(property.key) && property.key.name === "__id"
+                        );
+                        if (idProperty) {
+                          parameters.__id = idProperty.value.value;
+                        }
+                      }
+                      self._storyAnnotations[exportName][p.key.name] = p.value;
+                    }
+                  });
+                } else {
+                  parameters.__isArgsStory = isArgsStory(storyNode, parent, self);
+                }
+                self._stories[exportName] = {
                   id: "FIXME",
-                  name: l,
-                  parameters: {},
+                  name,
+                  parameters,
                   __stats: {}
                 };
-            }
-          });
+              }
+            });
+          } else if (node.specifiers.length > 0) {
+            node.specifiers.forEach((specifier) => {
+              if (t2.isExportSpecifier(specifier) && t2.isIdentifier(specifier.exported)) {
+                const { name: exportName } = specifier.exported;
+                const decl = t2.isProgram(parent) ? findVarInitialization(specifier.local.name, parent) : specifier.local;
+                if (exportName === "default") {
+                  let metaNode;
+                  if (t2.isObjectExpression(decl)) {
+                    metaNode = decl;
+                  } else if (
+                    // export default { ... } as Meta<...>
+                    t2.isTSAsExpression(decl) && t2.isObjectExpression(decl.expression)
+                  ) {
+                    metaNode = decl.expression;
+                  }
+                  if (!self._meta && metaNode && t2.isProgram(parent)) {
+                    self._parseMeta(metaNode, parent);
+                  }
+                } else {
+                  self._storyAnnotations[exportName] = {};
+                  self._storyStatements[exportName] = decl;
+                  self._stories[exportName] = {
+                    id: "FIXME",
+                    name: exportName,
+                    parameters: {},
+                    __stats: {}
+                  };
+                }
+              }
+            });
+          }
         }
       },
       ExpressionStatement: {
-        enter({ node: t, parent: r }) {
-          let { expression: a } = t;
-          if (c.isProgram(r) && c.isAssignmentExpression(a) && c.isMemberExpression(a.left) && c.isIdentifier(a.left.object) && c.isIdentifier(
-          a.left.property)) {
-            let n = a.left.object.name, l = a.left.property.name, u = a.right;
-            if (e._storyAnnotations[n] && (l === "story" && c.isObjectExpression(u) ? u.properties.forEach((d) => {
-              c.isIdentifier(d.key) && (e._storyAnnotations[n][d.key.name] = d.value);
-            }) : e._storyAnnotations[n][l] = u), l === "storyName" && c.isStringLiteral(u)) {
-              let d = u.value, x = e._stories[n];
-              if (!x)
+        enter({ node, parent }) {
+          const { expression } = node;
+          if (t2.isProgram(parent) && t2.isAssignmentExpression(expression) && t2.isMemberExpression(expression.left) && t2.isIdentifier(expression.
+          left.object) && t2.isIdentifier(expression.left.property)) {
+            const exportName = expression.left.object.name;
+            const annotationKey = expression.left.property.name;
+            const annotationValue = expression.right;
+            if (self._storyAnnotations[exportName]) {
+              if (annotationKey === "story" && t2.isObjectExpression(annotationValue)) {
+                annotationValue.properties.forEach((prop) => {
+                  if (t2.isIdentifier(prop.key)) {
+                    self._storyAnnotations[exportName][prop.key.name] = prop.value;
+                  }
+                });
+              } else {
+                self._storyAnnotations[exportName][annotationKey] = annotationValue;
+              }
+            }
+            if (annotationKey === "storyName" && t2.isStringLiteral(annotationValue)) {
+              const storyName = annotationValue.value;
+              const story = self._stories[exportName];
+              if (!story) {
                 return;
-              x.name = d;
+              }
+              story.name = storyName;
             }
           }
         }
       },
       CallExpression: {
-        enter({ node: t }) {
-          let { callee: r } = t;
-          if (c.isIdentifier(r) && r.name === "storiesOf")
-            throw new Error(F.dedent`
-              Unexpected \`storiesOf\` usage: ${$(t, e._options.fileName)}.
+        enter({ node }) {
+          const { callee } = node;
+          if (t2.isIdentifier(callee) && callee.name === "storiesOf") {
+            throw new Error(import_ts_dedent.dedent`
+              Unexpected \`storiesOf\` usage: ${formatLocation(node, self._options.fileName)}.
 
               SB8 does not support \`storiesOf\`. 
             `);
+          }
         }
       },
       ImportDeclaration: {
-        enter({ node: t }) {
-          let { source: r } = t;
-          if (c.isStringLiteral(r))
-            e.imports.push(r.value);
-          else
+        enter({ node }) {
+          const { source } = node;
+          if (t2.isStringLiteral(source)) {
+            self.imports.push(source.value);
+          } else {
             throw new Error("CSF: unexpected import source");
+          }
         }
       }
-    }), !e._meta)
-      throw new R("missing default export", e._ast, e._options.fileName);
-    let i = Object.entries(e._stories);
-    if (e._meta.title = this._options.makeTitle(e._meta?.title), e._metaAnnotations.play && (e._meta.tags = [...e._meta.tags || [], "play-fn"]),
-    e._stories = i.reduce(
-      (t, [r, a]) => {
-        if (!Z(r, e._meta))
-          return t;
-        let n = a.parameters?.__id ?? qe(e._meta?.id || e._meta?.title, ee(r)), l = { ...a.parameters, __id: n }, { includeStories: u } = e.
-        _meta || {};
-        r === "__page" && (i.length === 1 || Array.isArray(u) && u.length === 1) && (l.docsOnly = !0), t[r] = { ...a, id: n, parameters: l };
-        let d = e._storyAnnotations[r], { tags: x, play: g } = d;
-        if (x) {
-          let _ = c.isIdentifier(x) ? O(x.name, this._ast.program) : x;
-          t[r].tags = re(_);
+    });
+    if (!self._meta) {
+      throw new NoMetaError("missing default export", self._ast, self._options.fileName);
+    }
+    const entries = Object.entries(self._stories);
+    self._meta.title = this._options.makeTitle(self._meta?.title);
+    if (self._metaAnnotations.play) {
+      self._meta.tags = [...self._meta.tags || [], "play-fn"];
+    }
+    self._stories = entries.reduce(
+      (acc, [key, story]) => {
+        if (!isExportStory(key, self._meta)) {
+          return acc;
+        }
+        const id = story.parameters?.__id ?? toId(self._meta?.id || self._meta?.title, storyNameFromExport(key));
+        const parameters = { ...story.parameters, __id: id };
+        const { includeStories } = self._meta || {};
+        if (key === "__page" && (entries.length === 1 || Array.isArray(includeStories) && includeStories.length === 1)) {
+          parameters.docsOnly = true;
+        }
+        acc[key] = { ...story, id, parameters };
+        const storyAnnotations = self._storyAnnotations[key];
+        const { tags, play } = storyAnnotations;
+        if (tags) {
+          const node = t2.isIdentifier(tags) ? findVarInitialization(tags.name, this._ast.program) : tags;
+          acc[key].tags = parseTags(node);
+        }
+        if (play) {
+          acc[key].tags = [...acc[key].tags || [], "play-fn"];
         }
-        g && (t[r].tags = [...t[r].tags || [], "play-fn"]);
-        let b = t[r].__stats;
-        ["play", "render", "loaders", "beforeEach", "globals"].forEach((_) => {
-          b[_] = !!d[_] || !!e._metaAnnotations[_];
+        const stats = acc[key].__stats;
+        ["play", "render", "loaders", "beforeEach", "globals"].forEach((annotation) => {
+          stats[annotation] = !!storyAnnotations[annotation] || !!self._metaAnnotations[annotation];
         });
-        let h = e.getStoryExport(r);
-        return b.storyFn = !!(c.isArrowFunctionExpression(h) || c.isFunctionDeclaration(h)), b.mount = Ge(d.play ?? e._metaAnnotations.play),
-        b.moduleMock = !!e.imports.find((_) => We(_)), t;
+        const storyExport = self.getStoryExport(key);
+        stats.storyFn = !!(t2.isArrowFunctionExpression(storyExport) || t2.isFunctionDeclaration(storyExport));
+        stats.mount = hasMount(storyAnnotations.play ?? self._metaAnnotations.play);
+        stats.moduleMock = !!self.imports.find((fname) => isModuleMock(fname));
+        return acc;
       },
       {}
-    ), Object.keys(e._storyExports).forEach((t) => {
-      Z(t, e._meta) || (delete e._storyExports[t], delete e._storyAnnotations[t], delete e._storyStatements[t]);
-    }), e._namedExportsOrder) {
-      let t = Object.keys(e._storyExports);
-      e._storyExports = se(e._storyExports, e._namedExportsOrder), e._stories = se(e._stories, e._namedExportsOrder);
-      let r = Object.keys(e._storyExports);
-      if (t.length !== r.length)
+    );
+    Object.keys(self._storyExports).forEach((key) => {
+      if (!isExportStory(key, self._meta)) {
+        delete self._storyExports[key];
+        delete self._storyAnnotations[key];
+        delete self._storyStatements[key];
+      }
+    });
+    if (self._namedExportsOrder) {
+      const unsortedExports = Object.keys(self._storyExports);
+      self._storyExports = sortExports(self._storyExports, self._namedExportsOrder);
+      self._stories = sortExports(self._stories, self._namedExportsOrder);
+      const sortedExports = Object.keys(self._storyExports);
+      if (unsortedExports.length !== sortedExports.length) {
         throw new Error(
-          `Missing exports after sort: ${t.filter(
-            (a) => !r.includes(a)
+          `Missing exports after sort: ${unsortedExports.filter(
+            (key) => !sortedExports.includes(key)
           )}`
         );
+      }
     }
-    return e;
+    return self;
   }
   get meta() {
     return this._meta;
@@ -437,240 +605,365 @@ var $ = /* @__PURE__ */ p((s, e) => {
     return Object.values(this._stories);
   }
   get indexInputs() {
-    let { fileName: e } = this._options;
-    if (!e)
+    const { fileName } = this._options;
+    if (!fileName) {
       throw new Error(
-        F.dedent`Cannot automatically create index inputs with CsfFile.indexInputs because the CsfFile instance was created without a the fileName option.
+        import_ts_dedent.dedent`Cannot automatically create index inputs with CsfFile.indexInputs because the CsfFile instance was created without a the fileName option.
         Either add the fileName option when creating the CsfFile instance, or create the index inputs manually.`
       );
-    return Object.entries(this._stories).map(([i, t]) => {
-      let r = [...this._meta?.tags ?? [], ...t.tags ?? []];
+    }
+    return Object.entries(this._stories).map(([exportName, story]) => {
+      const tags = [...this._meta?.tags ?? [], ...story.tags ?? []];
       return {
         type: "story",
-        importPath: e,
+        importPath: fileName,
         rawComponentPath: this._rawComponentPath,
-        exportName: i,
-        name: t.name,
+        exportName,
+        name: story.name,
         title: this.meta?.title,
         metaId: this.meta?.id,
-        tags: r,
-        __id: t.id,
-        __stats: t.__stats
+        tags,
+        __id: story.id,
+        __stats: story.__stats
       };
     });
   }
-}, Ke = /* @__PURE__ */ p(({
-  code: s,
-  filename: e = "",
-  ast: i
-}) => new Me({ filename: e }, { code: s, ast: i ?? ne(s) }), "babelParseFile"), q = /* @__PURE__ */ p((s, e) => {
-  let i = ne(s), t = Ke({ code: s, filename: e.fileName, ast: i });
-  return new U(i, e, t);
-}, "loadCsf"), ae = /* @__PURE__ */ p((s, e = { sourceMaps: !1 }, i) => {
-  let t = $e(s._ast, e, i);
-  return e.sourceMaps ? t : t.code;
-}, "formatCsf"), Xe = /* @__PURE__ */ p((s, e = {}) => oe.print(s._ast, e), "printCsf"), Dt = /* @__PURE__ */ p(async (s, e) => {
-  let i = (await Re(s, "utf-8")).toString();
-  return q(i, { ...e, fileName: s });
-}, "readCsf"), vt = /* @__PURE__ */ p(async (s, e) => {
-  if (!(e || s._options.fileName))
+};
+var babelParseFile = /* @__PURE__ */ __name(({
+  code,
+  filename = "",
+  ast
+}) => {
+  return new BabelFileClass({ filename }, { code, ast: ast ?? babelParse(code) });
+}, "babelParseFile");
+var loadCsf = /* @__PURE__ */ __name((code, options) => {
+  const ast = babelParse(code);
+  const file = babelParseFile({ code, filename: options.fileName, ast });
+  return new CsfFile(ast, options, file);
+}, "loadCsf");
+var formatCsf = /* @__PURE__ */ __name((csf, options = { sourceMaps: false }, code) => {
+  const result = generate(csf._ast, options, code);
+  if (options.sourceMaps) {
+    return result;
+  }
+  return result.code;
+}, "formatCsf");
+var printCsf = /* @__PURE__ */ __name((csf, options = {}) => {
+  return recast.print(csf._ast, options);
+}, "printCsf");
+var readCsf = /* @__PURE__ */ __name(async (fileName, options) => {
+  const code = (await readFile(fileName, "utf-8")).toString();
+  return loadCsf(code, { ...options, fileName });
+}, "readCsf");
+var writeCsf = /* @__PURE__ */ __name(async (csf, fileName) => {
+  const fname = fileName || csf._options.fileName;
+  if (!fname) {
     throw new Error("Please specify a fileName for writeCsf");
-  await Le(e, Xe(s).code);
+  }
+  await writeFile(fileName, printCsf(csf).code);
 }, "writeCsf");
 
 // src/csf-tools/ConfigFile.ts
-var fe = A(N(), 1);
-import { readFile as Qe, writeFile as He } from "node:fs/promises";
+var import_ts_dedent2 = __toESM(require_dist(), 1);
+import { readFile as readFile2, writeFile as writeFile2 } from "node:fs/promises";
 import {
-  babelParse as pe,
-  generate as le,
-  recast as Ye,
-  types as o,
-  traverse as ce
+  babelParse as babelParse2,
+  generate as generate2,
+  recast as recast2,
+  types as t3,
+  traverse as traverse2
 } from "@storybook/core/babel";
-var B = console, W = /* @__PURE__ */ p(({
-  expectedType: s,
-  foundType: e,
-  node: i
+var logger2 = console;
+var getCsfParsingErrorMessage = /* @__PURE__ */ __name(({
+  expectedType,
+  foundType,
+  node
 }) => {
-  let t = "";
-  if (i)
+  let nodeInfo = "";
+  if (node) {
     try {
-      t = JSON.stringify(i);
-    } catch {
+      nodeInfo = JSON.stringify(node);
+    } catch (e) {
     }
-  return fe.dedent`
-      CSF Parsing error: Expected '${s}' but found '${e}' instead in '${i?.type}'.
-      ${t}
+  }
+  return import_ts_dedent2.dedent`
+      CSF Parsing error: Expected '${expectedType}' but found '${foundType}' instead in '${node?.type}'.
+      ${nodeInfo}
     `;
-}, "getCsfParsingErrorMessage"), C = /* @__PURE__ */ p((s) => o.isIdentifier(s.key) ? s.key.name : o.isStringLiteral(s.key) ? s.key.value : null,
-"propKey"), L = /* @__PURE__ */ p((s) => o.isTSAsExpression(s) || o.isTSSatisfiesExpression(s) ? L(s.expression) : s, "unwrap"), de = /* @__PURE__ */ p(
-(s, e) => {
-  if (s.length === 0)
-    return e;
-  if (o.isObjectExpression(e)) {
-    let [i, ...t] = s, r = e.properties.find((a) => C(a) === i);
-    if (r)
-      return de(t, r.value);
-  }
-}, "_getPath"), ue = /* @__PURE__ */ p((s, e) => {
-  if (s.length === 0) {
-    if (o.isObjectExpression(e))
-      return e.properties;
+}, "getCsfParsingErrorMessage");
+var propKey = /* @__PURE__ */ __name((p) => {
+  if (t3.isIdentifier(p.key)) {
+    return p.key.name;
+  }
+  if (t3.isStringLiteral(p.key)) {
+    return p.key.value;
+  }
+  return null;
+}, "propKey");
+var unwrap = /* @__PURE__ */ __name((node) => {
+  if (t3.isTSAsExpression(node) || t3.isTSSatisfiesExpression(node)) {
+    return unwrap(node.expression);
+  }
+  return node;
+}, "unwrap");
+var _getPath = /* @__PURE__ */ __name((path, node) => {
+  if (path.length === 0) {
+    return node;
+  }
+  if (t3.isObjectExpression(node)) {
+    const [first, ...rest] = path;
+    const field = node.properties.find((p) => propKey(p) === first);
+    if (field) {
+      return _getPath(rest, field.value);
+    }
+  }
+  return void 0;
+}, "_getPath");
+var _getPathProperties = /* @__PURE__ */ __name((path, node) => {
+  if (path.length === 0) {
+    if (t3.isObjectExpression(node)) {
+      return node.properties;
+    }
     throw new Error("Expected object expression");
   }
-  if (o.isObjectExpression(e)) {
-    let [i, ...t] = s, r = e.properties.find((a) => C(a) === i);
-    if (r)
-      return t.length === 0 ? e.properties : ue(t, r.value);
-  }
-}, "_getPathProperties"), me = /* @__PURE__ */ p((s, e) => {
-  let i = null, t = null;
-  return e.body.find((r) => (o.isVariableDeclaration(r) ? t = r.declarations : o.isExportNamedDeclaration(r) && o.isVariableDeclaration(r.declaration) &&
-  (t = r.declaration.declarations), t && t.find((a) => o.isVariableDeclarator(a) && o.isIdentifier(a.id) && a.id.name === s ? (i = a, !0) : !1))),
-  i;
-}, "_findVarDeclarator"), D = /* @__PURE__ */ p((s, e) => me(s, e)?.init, "_findVarInitialization"), T = /* @__PURE__ */ p((s, e) => {
-  if (s.length === 0)
-    return e;
-  let [i, ...t] = s, r = T(t, e);
-  return o.objectExpression([o.objectProperty(o.identifier(i), r)]);
-}, "_makeObjectExpression"), z = /* @__PURE__ */ p((s, e, i) => {
-  let [t, ...r] = s, a = i.properties.find(
-    (n) => C(n) === t
-  );
-  a ? o.isObjectExpression(a.value) && r.length > 0 ? z(r, e, a.value) : a.value = T(r, e) : i.properties.push(
-    o.objectProperty(o.identifier(t), T(r, e))
+  if (t3.isObjectExpression(node)) {
+    const [first, ...rest] = path;
+    const field = node.properties.find((p) => propKey(p) === first);
+    if (field) {
+      if (rest.length === 0) {
+        return node.properties;
+      }
+      return _getPathProperties(rest, field.value);
+    }
+  }
+  return void 0;
+}, "_getPathProperties");
+var _findVarDeclarator = /* @__PURE__ */ __name((identifier, program) => {
+  let declarator = null;
+  let declarations = null;
+  program.body.find((node) => {
+    if (t3.isVariableDeclaration(node)) {
+      declarations = node.declarations;
+    } else if (t3.isExportNamedDeclaration(node) && t3.isVariableDeclaration(node.declaration)) {
+      declarations = node.declaration.declarations;
+    }
+    return declarations && declarations.find((decl) => {
+      if (t3.isVariableDeclarator(decl) && t3.isIdentifier(decl.id) && decl.id.name === identifier) {
+        declarator = decl;
+        return true;
+      }
+      return false;
+    });
+  });
+  return declarator;
+}, "_findVarDeclarator");
+var _findVarInitialization = /* @__PURE__ */ __name((identifier, program) => {
+  const declarator = _findVarDeclarator(identifier, program);
+  return declarator?.init;
+}, "_findVarInitialization");
+var _makeObjectExpression = /* @__PURE__ */ __name((path, value) => {
+  if (path.length === 0) {
+    return value;
+  }
+  const [first, ...rest] = path;
+  const innerExpression = _makeObjectExpression(rest, value);
+  return t3.objectExpression([t3.objectProperty(t3.identifier(first), innerExpression)]);
+}, "_makeObjectExpression");
+var _updateExportNode = /* @__PURE__ */ __name((path, expr, existing) => {
+  const [first, ...rest] = path;
+  const existingField = existing.properties.find(
+    (p) => propKey(p) === first
   );
-}, "_updateExportNode"), G = class {
-  constructor(e, i, t) {
+  if (!existingField) {
+    existing.properties.push(
+      t3.objectProperty(t3.identifier(first), _makeObjectExpression(rest, expr))
+    );
+  } else if (t3.isObjectExpression(existingField.value) && rest.length > 0) {
+    _updateExportNode(rest, expr, existingField.value);
+  } else {
+    existingField.value = _makeObjectExpression(rest, expr);
+  }
+}, "_updateExportNode");
+var ConfigFile = class {
+  constructor(ast, code, fileName) {
     this._exports = {};
     // FIXME: this is a hack. this is only used in the case where the user is
     // modifying a named export that's a scalar. The _exports map is not suitable
     // for that. But rather than refactor the whole thing, we just use this as a stopgap.
     this._exportDecls = {};
-    this.hasDefaultExport = !1;
-    this._ast = e, this._code = i, this.fileName = t;
+    this.hasDefaultExport = false;
+    this._ast = ast;
+    this._code = code;
+    this.fileName = fileName;
   }
   static {
-    p(this, "ConfigFile");
+    __name(this, "ConfigFile");
   }
   parse() {
-    let e = this;
-    return ce(this._ast, {
+    const self = this;
+    traverse2(this._ast, {
       ExportDefaultDeclaration: {
-        enter({ node: i, parent: t }) {
-          e.hasDefaultExport = !0;
-          let r = o.isIdentifier(i.declaration) && o.isProgram(t) ? D(i.declaration.name, t) : i.declaration;
-          r = L(r), o.isObjectExpression(r) ? (e._exportsObject = r, r.properties.forEach((a) => {
-            let n = C(a);
-            if (n) {
-              let l = a.value;
-              o.isIdentifier(l) && (l = D(l.name, t)), e._exports[n] = l;
-            }
-          })) : B.warn(
-            W({
-              expectedType: "ObjectExpression",
-              foundType: r?.type,
-              node: r || i.declaration
-            })
-          );
+        enter({ node, parent }) {
+          self.hasDefaultExport = true;
+          let decl = t3.isIdentifier(node.declaration) && t3.isProgram(parent) ? _findVarInitialization(node.declaration.name, parent) : node.
+          declaration;
+          decl = unwrap(decl);
+          if (t3.isObjectExpression(decl)) {
+            self._exportsObject = decl;
+            decl.properties.forEach((p) => {
+              const exportName = propKey(p);
+              if (exportName) {
+                let exportVal = p.value;
+                if (t3.isIdentifier(exportVal)) {
+                  exportVal = _findVarInitialization(exportVal.name, parent);
+                }
+                self._exports[exportName] = exportVal;
+              }
+            });
+          } else {
+            logger2.warn(
+              getCsfParsingErrorMessage({
+                expectedType: "ObjectExpression",
+                foundType: decl?.type,
+                node: decl || node.declaration
+              })
+            );
+          }
         }
       },
       ExportNamedDeclaration: {
-        enter({ node: i, parent: t }) {
-          o.isVariableDeclaration(i.declaration) ? i.declaration.declarations.forEach((r) => {
-            if (o.isVariableDeclarator(r) && o.isIdentifier(r.id)) {
-              let { name: a } = r.id, n = r.init;
-              o.isIdentifier(n) && (n = D(n.name, t)), e._exports[a] = n, e._exportDecls[a] = r;
-            }
-          }) : i.specifiers ? i.specifiers.forEach((r) => {
-            if (o.isExportSpecifier(r) && o.isIdentifier(r.local) && o.isIdentifier(r.exported)) {
-              let { name: a } = r.local, { name: n } = r.exported, l = me(a, t);
-              e._exports[n] = l.init, e._exportDecls[n] = l;
-            }
-          }) : B.warn(
-            W({
-              expectedType: "VariableDeclaration",
-              foundType: i.declaration?.type,
-              node: i.declaration
-            })
-          );
+        enter({ node, parent }) {
+          if (t3.isVariableDeclaration(node.declaration)) {
+            node.declaration.declarations.forEach((decl) => {
+              if (t3.isVariableDeclarator(decl) && t3.isIdentifier(decl.id)) {
+                const { name: exportName } = decl.id;
+                let exportVal = decl.init;
+                if (t3.isIdentifier(exportVal)) {
+                  exportVal = _findVarInitialization(exportVal.name, parent);
+                }
+                self._exports[exportName] = exportVal;
+                self._exportDecls[exportName] = decl;
+              }
+            });
+          } else if (node.specifiers) {
+            node.specifiers.forEach((spec) => {
+              if (t3.isExportSpecifier(spec) && t3.isIdentifier(spec.local) && t3.isIdentifier(spec.exported)) {
+                const { name: localName } = spec.local;
+                const { name: exportName } = spec.exported;
+                const decl = _findVarDeclarator(localName, parent);
+                self._exports[exportName] = decl.init;
+                self._exportDecls[exportName] = decl;
+              }
+            });
+          } else {
+            logger2.warn(
+              getCsfParsingErrorMessage({
+                expectedType: "VariableDeclaration",
+                foundType: node.declaration?.type,
+                node: node.declaration
+              })
+            );
+          }
         }
       },
       ExpressionStatement: {
-        enter({ node: i, parent: t }) {
-          if (o.isAssignmentExpression(i.expression) && i.expression.operator === "=") {
-            let { left: r, right: a } = i.expression;
-            if (o.isMemberExpression(r) && o.isIdentifier(r.object) && r.object.name === "module" && o.isIdentifier(r.property) && r.property.
-            name === "exports") {
-              let n = a;
-              o.isIdentifier(a) && (n = D(a.name, t)), n = L(n), o.isObjectExpression(n) ? (e._exportsObject = n, n.properties.forEach((l) => {
-                let u = C(l);
-                if (u) {
-                  let d = l.value;
-                  o.isIdentifier(d) && (d = D(
-                    d.name,
-                    t
-                  )), e._exports[u] = d;
-                }
-              })) : B.warn(
-                W({
-                  expectedType: "ObjectExpression",
-                  foundType: n?.type,
-                  node: n
-                })
-              );
+        enter({ node, parent }) {
+          if (t3.isAssignmentExpression(node.expression) && node.expression.operator === "=") {
+            const { left, right } = node.expression;
+            if (t3.isMemberExpression(left) && t3.isIdentifier(left.object) && left.object.name === "module" && t3.isIdentifier(left.property) &&
+            left.property.name === "exports") {
+              let exportObject = right;
+              if (t3.isIdentifier(right)) {
+                exportObject = _findVarInitialization(right.name, parent);
+              }
+              exportObject = unwrap(exportObject);
+              if (t3.isObjectExpression(exportObject)) {
+                self._exportsObject = exportObject;
+                exportObject.properties.forEach((p) => {
+                  const exportName = propKey(p);
+                  if (exportName) {
+                    let exportVal = p.value;
+                    if (t3.isIdentifier(exportVal)) {
+                      exportVal = _findVarInitialization(
+                        exportVal.name,
+                        parent
+                      );
+                    }
+                    self._exports[exportName] = exportVal;
+                  }
+                });
+              } else {
+                logger2.warn(
+                  getCsfParsingErrorMessage({
+                    expectedType: "ObjectExpression",
+                    foundType: exportObject?.type,
+                    node: exportObject
+                  })
+                );
+              }
             }
           }
         }
       }
-    }), e;
-  }
-  getFieldNode(e) {
-    let [i, ...t] = e, r = this._exports[i];
-    if (r)
-      return de(t, r);
-  }
-  getFieldProperties(e) {
-    let [i, ...t] = e, r = this._exports[i];
-    if (r)
-      return ue(t, r);
-  }
-  getFieldValue(e) {
-    let i = this.getFieldNode(e);
-    if (i) {
-      let { code: t } = le(i, {});
-      return (0, eval)(`(() => (${t}))()`);
+    });
+    return self;
+  }
+  getFieldNode(path) {
+    const [root, ...rest] = path;
+    const exported = this._exports[root];
+    if (!exported) {
+      return void 0;
+    }
+    return _getPath(rest, exported);
+  }
+  getFieldProperties(path) {
+    const [root, ...rest] = path;
+    const exported = this._exports[root];
+    if (!exported) {
+      return void 0;
+    }
+    return _getPathProperties(rest, exported);
+  }
+  getFieldValue(path) {
+    const node = this.getFieldNode(path);
+    if (node) {
+      const { code } = generate2(node, {});
+      const value = (0, eval)(`(() => (${code}))()`);
+      return value;
     }
+    return void 0;
   }
-  getSafeFieldValue(e) {
+  getSafeFieldValue(path) {
     try {
-      return this.getFieldValue(e);
-    } catch {
+      return this.getFieldValue(path);
+    } catch (e) {
     }
+    return void 0;
   }
-  setFieldNode(e, i) {
-    let [t, ...r] = e, a = this._exports[t];
-    if (this._exportsObject)
-      z(e, i, this._exportsObject), this._exports[e[0]] = i;
-    else if (a && o.isObjectExpression(a) && r.length > 0)
-      z(r, i, a);
-    else if (a && r.length === 0 && this._exportDecls[e[0]]) {
-      let n = this._exportDecls[e[0]];
-      n.init = T([], i);
+  setFieldNode(path, expr) {
+    const [first, ...rest] = path;
+    const exportNode = this._exports[first];
+    if (this._exportsObject) {
+      _updateExportNode(path, expr, this._exportsObject);
+      this._exports[path[0]] = expr;
+    } else if (exportNode && t3.isObjectExpression(exportNode) && rest.length > 0) {
+      _updateExportNode(rest, expr, exportNode);
+    } else if (exportNode && rest.length === 0 && this._exportDecls[path[0]]) {
+      const decl = this._exportDecls[path[0]];
+      decl.init = _makeObjectExpression([], expr);
+    } else if (this.hasDefaultExport) {
+      throw new Error(
+        `Could not set the "${path.join(
+          "."
+        )}" field as the default export is not an object in this file.`
+      );
     } else {
-      if (this.hasDefaultExport)
-        throw new Error(
-          `Could not set the "${e.join(
-            "."
-          )}" field as the default export is not an object in this file.`
-        );
-      {
-        let n = T(r, i), l = o.exportNamedDeclaration(
-          o.variableDeclaration("const", [o.variableDeclarator(o.identifier(t), n)])
-        );
-        this._exports[t] = n, this._ast.program.body.push(l);
-      }
+      const exportObj = _makeObjectExpression(rest, expr);
+      const newExport = t3.exportNamedDeclaration(
+        t3.variableDeclaration("const", [t3.variableDeclarator(t3.identifier(first), exportObj)])
+      );
+      this._exports[first] = exportObj;
+      this._ast.program.body.push(newExport);
     }
   }
   /**
@@ -684,10 +977,12 @@ var B = console, W = /* @__PURE__ */ p(({
    *
    * @returns The name of a node in a given path, supporting the following formats:
    */
-  getNameFromPath(e) {
-    let i = this.getFieldNode(e);
-    if (i)
-      return this._getPresetValue(i, "name");
+  getNameFromPath(path) {
+    const node = this.getFieldNode(path);
+    if (!node) {
+      return void 0;
+    }
+    return this._getPresetValue(node, "name");
   }
   /**
    * Returns an array of names of a node in a given path, supporting the following formats:
@@ -702,21 +997,27 @@ var B = console, W = /* @__PURE__ */ p(({
    * getNamesFromPath(['addons']);
    * ```
    */
-  getNamesFromPath(e) {
-    let i = this.getFieldNode(e);
-    if (!i)
-      return;
-    let t = [];
-    return o.isArrayExpression(i) && i.elements.forEach((r) => {
-      t.push(this._getPresetValue(r, "name"));
-    }), t;
-  }
-  _getPnpWrappedValue(e) {
-    if (o.isCallExpression(e)) {
-      let i = e.arguments[0];
-      if (o.isStringLiteral(i))
-        return i.value;
+  getNamesFromPath(path) {
+    const node = this.getFieldNode(path);
+    if (!node) {
+      return void 0;
+    }
+    const pathNames = [];
+    if (t3.isArrayExpression(node)) {
+      node.elements.forEach((element) => {
+        pathNames.push(this._getPresetValue(element, "name"));
+      });
     }
+    return pathNames;
+  }
+  _getPnpWrappedValue(node) {
+    if (t3.isCallExpression(node)) {
+      const arg = node.arguments[0];
+      if (t3.isStringLiteral(arg)) {
+        return arg.value;
+      }
+    }
+    return void 0;
   }
   /**
    * Given a node and a fallback property, returns a **non-evaluated** string value of the node.
@@ -724,120 +1025,173 @@ var B = console, W = /* @__PURE__ */ p(({
    * 1. `{ node: 'value' }`
    * 2. `{ node: { fallbackProperty: 'value' } }`
    */
-  _getPresetValue(e, i) {
-    let t;
-    if (o.isStringLiteral(e) ? t = e.value : o.isObjectExpression(e) && e.properties.forEach((r) => {
-      o.isObjectProperty(r) && o.isIdentifier(r.key) && r.key.name === i && (o.isStringLiteral(r.value) ? t = r.value.value : t = this._getPnpWrappedValue(
-      r.value)), o.isObjectProperty(r) && o.isStringLiteral(r.key) && r.key.value === "name" && o.isStringLiteral(r.value) && (t = r.value.value);
-    }), !t)
+  _getPresetValue(node, fallbackProperty) {
+    let value;
+    if (t3.isStringLiteral(node)) {
+      value = node.value;
+    } else if (t3.isObjectExpression(node)) {
+      node.properties.forEach((prop) => {
+        if (t3.isObjectProperty(prop) && t3.isIdentifier(prop.key) && prop.key.name === fallbackProperty) {
+          if (t3.isStringLiteral(prop.value)) {
+            value = prop.value.value;
+          } else {
+            value = this._getPnpWrappedValue(prop.value);
+          }
+        }
+        if (t3.isObjectProperty(prop) && t3.isStringLiteral(prop.key) && prop.key.value === "name" && t3.isStringLiteral(prop.value)) {
+          value = prop.value.value;
+        }
+      });
+    }
+    if (!value) {
       throw new Error(
-        `The given node must be a string literal or an object expression with a "${i}" property that is a string literal.`
+        `The given node must be a string literal or an object expression with a "${fallbackProperty}" property that is a string literal.`
       );
-    return t;
+    }
+    return value;
   }
-  removeField(e) {
-    let i = /* @__PURE__ */ p((r, a) => {
-      let n = r.findIndex(
-        (l) => o.isIdentifier(l.key) && l.key.name === a || o.isStringLiteral(l.key) && l.key.value === a
+  removeField(path) {
+    const removeProperty = /* @__PURE__ */ __name((properties2, prop) => {
+      const index = properties2.findIndex(
+        (p) => t3.isIdentifier(p.key) && p.key.name === prop || t3.isStringLiteral(p.key) && p.key.value === prop
       );
-      n >= 0 && r.splice(n, 1);
+      if (index >= 0) {
+        properties2.splice(index, 1);
+      }
     }, "removeProperty");
-    if (e.length === 1) {
-      let r = !1;
-      if (this._ast.program.body.forEach((a) => {
-        if (o.isExportNamedDeclaration(a) && o.isVariableDeclaration(a.declaration)) {
-          let n = a.declaration.declarations[0];
-          o.isIdentifier(n.id) && n.id.name === e[0] && (this._ast.program.body.splice(this._ast.program.body.indexOf(a), 1), r = !0);
+    if (path.length === 1) {
+      let removedRootProperty = false;
+      this._ast.program.body.forEach((node) => {
+        if (t3.isExportNamedDeclaration(node) && t3.isVariableDeclaration(node.declaration)) {
+          const decl = node.declaration.declarations[0];
+          if (t3.isIdentifier(decl.id) && decl.id.name === path[0]) {
+            this._ast.program.body.splice(this._ast.program.body.indexOf(node), 1);
+            removedRootProperty = true;
+          }
         }
-        if (o.isExportDefaultDeclaration(a)) {
-          let n = a.declaration;
-          if (o.isIdentifier(n) && (n = D(n.name, this._ast.program)), n = L(n), o.isObjectExpression(n)) {
-            let l = n.properties;
-            i(l, e[0]), r = !0;
+        if (t3.isExportDefaultDeclaration(node)) {
+          let decl = node.declaration;
+          if (t3.isIdentifier(decl)) {
+            decl = _findVarInitialization(decl.name, this._ast.program);
+          }
+          decl = unwrap(decl);
+          if (t3.isObjectExpression(decl)) {
+            const properties2 = decl.properties;
+            removeProperty(properties2, path[0]);
+            removedRootProperty = true;
           }
         }
-        if (o.isExpressionStatement(a) && o.isAssignmentExpression(a.expression) && o.isMemberExpression(a.expression.left) && o.isIdentifier(
-        a.expression.left.object) && a.expression.left.object.name === "module" && o.isIdentifier(a.expression.left.property) && a.expression.
-        left.property.name === "exports" && o.isObjectExpression(a.expression.right)) {
-          let n = a.expression.right.properties;
-          i(n, e[0]), r = !0;
+        if (t3.isExpressionStatement(node) && t3.isAssignmentExpression(node.expression) && t3.isMemberExpression(node.expression.left) && t3.
+        isIdentifier(node.expression.left.object) && node.expression.left.object.name === "module" && t3.isIdentifier(node.expression.left.property) &&
+        node.expression.left.property.name === "exports" && t3.isObjectExpression(node.expression.right)) {
+          const properties2 = node.expression.right.properties;
+          removeProperty(properties2, path[0]);
+          removedRootProperty = true;
         }
-      }), r)
+      });
+      if (removedRootProperty) {
         return;
+      }
     }
-    let t = this.getFieldProperties(e);
-    if (t) {
-      let r = e.at(-1);
-      i(t, r);
+    const properties = this.getFieldProperties(path);
+    if (properties) {
+      const lastPath = path.at(-1);
+      removeProperty(properties, lastPath);
     }
   }
-  appendValueToArray(e, i) {
-    let t = this.valueToNode(i);
-    t && this.appendNodeToArray(e, t);
+  appendValueToArray(path, value) {
+    const node = this.valueToNode(value);
+    if (node) {
+      this.appendNodeToArray(path, node);
+    }
   }
-  appendNodeToArray(e, i) {
-    let t = this.getFieldNode(e);
-    if (!t)
-      this.setFieldNode(e, o.arrayExpression([i]));
-    else if (o.isArrayExpression(t))
-      t.elements.push(i);
-    else
-      throw new Error(`Expected array at '${e.join(".")}', got '${t.type}'`);
+  appendNodeToArray(path, node) {
+    const current = this.getFieldNode(path);
+    if (!current) {
+      this.setFieldNode(path, t3.arrayExpression([node]));
+    } else if (t3.isArrayExpression(current)) {
+      current.elements.push(node);
+    } else {
+      throw new Error(`Expected array at '${path.join(".")}', got '${current.type}'`);
+    }
   }
   /**
    * Specialized helper to remove addons or other array entries that can either be strings or
    * objects with a name property.
    */
-  removeEntryFromArray(e, i) {
-    let t = this.getFieldNode(e);
-    if (t)
-      if (o.isArrayExpression(t)) {
-        let r = t.elements.findIndex((a) => o.isStringLiteral(a) ? a.value === i : o.isObjectExpression(a) ? this._getPresetValue(a, "name") ===
-        i : this._getPnpWrappedValue(a) === i);
-        if (r >= 0)
-          t.elements.splice(r, 1);
-        else
-          throw new Error(`Could not find '${i}' in array at '${e.join(".")}'`);
-      } else
-        throw new Error(`Expected array at '${e.join(".")}', got '${t.type}'`);
+  removeEntryFromArray(path, value) {
+    const current = this.getFieldNode(path);
+    if (!current) {
+      return;
+    }
+    if (t3.isArrayExpression(current)) {
+      const index = current.elements.findIndex((element) => {
+        if (t3.isStringLiteral(element)) {
+          return element.value === value;
+        }
+        if (t3.isObjectExpression(element)) {
+          const name = this._getPresetValue(element, "name");
+          return name === value;
+        }
+        return this._getPnpWrappedValue(element) === value;
+      });
+      if (index >= 0) {
+        current.elements.splice(index, 1);
+      } else {
+        throw new Error(`Could not find '${value}' in array at '${path.join(".")}'`);
+      }
+    } else {
+      throw new Error(`Expected array at '${path.join(".")}', got '${current.type}'`);
+    }
   }
   _inferQuotes() {
     if (!this._quotes) {
-      let e = (this._ast.tokens || []).slice(0, 500).reduce(
-        (i, t) => (t.type.label === "string" && (i[this._code[t.start]] += 1), i),
+      const occurrences = (this._ast.tokens || []).slice(0, 500).reduce(
+        (acc, token) => {
+          if (token.type.label === "string") {
+            acc[this._code[token.start]] += 1;
+          }
+          return acc;
+        },
         { "'": 0, '"': 0 }
       );
-      this._quotes = e["'"] > e['"'] ? "single" : "double";
+      this._quotes = occurrences["'"] > occurrences['"'] ? "single" : "double";
     }
     return this._quotes;
   }
-  valueToNode(e) {
-    let i = this._inferQuotes(), t;
-    if (i === "single") {
-      let { code: r } = le(o.valueToNode(e), { jsescOption: { quotes: i } }), a = pe(`const __x = ${r}`);
-      ce(a, {
+  valueToNode(value) {
+    const quotes = this._inferQuotes();
+    let valueNode;
+    if (quotes === "single") {
+      const { code } = generate2(t3.valueToNode(value), { jsescOption: { quotes } });
+      const program = babelParse2(`const __x = ${code}`);
+      traverse2(program, {
         VariableDeclaration: {
-          enter({ node: n }) {
-            n.declarations.length === 1 && o.isVariableDeclarator(n.declarations[0]) && o.isIdentifier(n.declarations[0].id) && n.declarations[0].
-            id.name === "__x" && (t = n.declarations[0].init);
+          enter({ node }) {
+            if (node.declarations.length === 1 && t3.isVariableDeclarator(node.declarations[0]) && t3.isIdentifier(node.declarations[0].id) &&
+            node.declarations[0].id.name === "__x") {
+              valueNode = node.declarations[0].init;
+            }
           }
         }
       });
-    } else
-      t = o.valueToNode(e);
-    return t;
+    } else {
+      valueNode = t3.valueToNode(value);
+    }
+    return valueNode;
   }
-  setFieldValue(e, i) {
-    let t = this.valueToNode(i);
-    if (!t)
-      throw new Error(`Unexpected value ${JSON.stringify(i)}`);
-    this.setFieldNode(e, t);
+  setFieldValue(path, value) {
+    const valueNode = this.valueToNode(value);
+    if (!valueNode) {
+      throw new Error(`Unexpected value ${JSON.stringify(value)}`);
+    }
+    this.setFieldNode(path, valueNode);
   }
   getBodyDeclarations() {
     return this._ast.program.body;
   }
-  setBodyDeclaration(e) {
-    this._ast.program.body.push(e);
+  setBodyDeclaration(declaration) {
+    this._ast.program.body.push(declaration);
   }
   /**
    * Import specifiers for a specific require import
@@ -856,43 +1210,59 @@ var B = console, W = /* @__PURE__ */ p(({
    *   import will be set. Otherwise, an array of named imports will be set
    * @param fromImport - The module to import from
    */
-  setRequireImport(e, i) {
-    let t = this._ast.program.body.find(
-      (n) => o.isVariableDeclaration(n) && n.declarations.length === 1 && o.isVariableDeclarator(n.declarations[0]) && o.isCallExpression(n.
-      declarations[0].init) && o.isIdentifier(n.declarations[0].init.callee) && n.declarations[0].init.callee.name === "require" && o.isStringLiteral(
-      n.declarations[0].init.arguments[0]) && n.declarations[0].init.arguments[0].value === i
-    ), r = /* @__PURE__ */ p((n) => o.isObjectPattern(t?.declarations[0].id) && t?.declarations[0].id.properties.find(
-      (l) => o.isObjectProperty(l) && o.isIdentifier(l.key) && l.key.name === n
-    ), "hasRequireSpecifier"), a = /* @__PURE__ */ p((n, l) => n.declarations.length === 1 && o.isVariableDeclarator(n.declarations[0]) && o.
-    isIdentifier(n.declarations[0].id) && n.declarations[0].id.name === l, "hasDefaultRequireSpecifier");
-    if (typeof e == "string") {
-      let n = /* @__PURE__ */ p(() => {
+  setRequireImport(importSpecifier, fromImport) {
+    const requireDeclaration = this._ast.program.body.find(
+      (node) => t3.isVariableDeclaration(node) && node.declarations.length === 1 && t3.isVariableDeclarator(node.declarations[0]) && t3.isCallExpression(
+      node.declarations[0].init) && t3.isIdentifier(node.declarations[0].init.callee) && node.declarations[0].init.callee.name === "require" &&
+      t3.isStringLiteral(node.declarations[0].init.arguments[0]) && node.declarations[0].init.arguments[0].value === fromImport
+    );
+    const hasRequireSpecifier = /* @__PURE__ */ __name((name) => t3.isObjectPattern(requireDeclaration?.declarations[0].id) && requireDeclaration?.
+    declarations[0].id.properties.find(
+      (specifier) => t3.isObjectProperty(specifier) && t3.isIdentifier(specifier.key) && specifier.key.name === name
+    ), "hasRequireSpecifier");
+    const hasDefaultRequireSpecifier = /* @__PURE__ */ __name((declaration, name) => declaration.declarations.length === 1 && t3.isVariableDeclarator(
+    declaration.declarations[0]) && t3.isIdentifier(declaration.declarations[0].id) && declaration.declarations[0].id.name === name, "hasDef\
+aultRequireSpecifier");
+    if (typeof importSpecifier === "string") {
+      const addDefaultRequireSpecifier = /* @__PURE__ */ __name(() => {
         this._ast.program.body.unshift(
-          o.variableDeclaration("const", [
-            o.variableDeclarator(
-              o.identifier(e),
-              o.callExpression(o.identifier("require"), [o.stringLiteral(i)])
+          t3.variableDeclaration("const", [
+            t3.variableDeclarator(
+              t3.identifier(importSpecifier),
+              t3.callExpression(t3.identifier("require"), [t3.stringLiteral(fromImport)])
             )
           ])
         );
       }, "addDefaultRequireSpecifier");
-      t && a(t, e) || n();
-    } else t ? e.forEach((n) => {
-      r(n) || t.declarations[0].id.properties.push(
-        o.objectProperty(o.identifier(n), o.identifier(n), void 0, !0)
+      if (requireDeclaration) {
+        if (!hasDefaultRequireSpecifier(requireDeclaration, importSpecifier)) {
+          addDefaultRequireSpecifier();
+        }
+      } else {
+        addDefaultRequireSpecifier();
+      }
+    } else if (requireDeclaration) {
+      importSpecifier.forEach((specifier) => {
+        if (!hasRequireSpecifier(specifier)) {
+          requireDeclaration.declarations[0].id.properties.push(
+            t3.objectProperty(t3.identifier(specifier), t3.identifier(specifier), void 0, true)
+          );
+        }
+      });
+    } else {
+      this._ast.program.body.unshift(
+        t3.variableDeclaration("const", [
+          t3.variableDeclarator(
+            t3.objectPattern(
+              importSpecifier.map(
+                (specifier) => t3.objectProperty(t3.identifier(specifier), t3.identifier(specifier), void 0, true)
+              )
+            ),
+            t3.callExpression(t3.identifier("require"), [t3.stringLiteral(fromImport)])
+          )
+        ])
       );
-    }) : this._ast.program.body.unshift(
-      o.variableDeclaration("const", [
-        o.variableDeclarator(
-          o.objectPattern(
-            e.map(
-              (n) => o.objectProperty(o.identifier(n), o.identifier(n), void 0, !0)
-            )
-          ),
-          o.callExpression(o.identifier("require"), [o.stringLiteral(i)])
-        )
-      ])
-    );
+    }
   }
   /**
    * Set import specifiers for a given import statement.
@@ -913,68 +1283,111 @@ var B = console, W = /* @__PURE__ */ p(({
    *   import will be set. Otherwise, an array of named imports will be set
    * @param fromImport - The module to import from
    */
-  setImport(e, i) {
-    let t = /* @__PURE__ */ p((l) => o.importSpecifier(o.identifier(l), o.identifier(l)), "getNewImportSpecifier"), r = /* @__PURE__ */ p((l, u) => l.
-    specifiers.find(
-      (d) => o.isImportSpecifier(d) && o.isIdentifier(d.imported) && d.imported.name === u
-    ), "hasImportSpecifier"), a = /* @__PURE__ */ p((l, u) => l.specifiers.find((d) => o.isImportDefaultSpecifier(d)), "hasDefaultImportSpec\
-ifier"), n = this._ast.program.body.find(
-      (l) => o.isImportDeclaration(l) && l.source.value === i
-    );
-    typeof e == "string" ? n ? a(n, e) || n.specifiers.push(
-      o.importDefaultSpecifier(o.identifier(e))
-    ) : this._ast.program.body.unshift(
-      o.importDeclaration(
-        [o.importDefaultSpecifier(o.identifier(e))],
-        o.stringLiteral(i)
-      )
-    ) : n ? e.forEach((l) => {
-      r(n, l) || n.specifiers.push(t(l));
-    }) : this._ast.program.body.unshift(
-      o.importDeclaration(
-        e.map(
-          (l) => o.importSpecifier(o.identifier(l), o.identifier(l))
-        ),
-        o.stringLiteral(i)
-      )
+  setImport(importSpecifier, fromImport) {
+    const getNewImportSpecifier = /* @__PURE__ */ __name((specifier) => t3.importSpecifier(t3.identifier(specifier), t3.identifier(specifier)),
+    "getNewImportSpecifier");
+    const hasImportSpecifier = /* @__PURE__ */ __name((declaration, name) => declaration.specifiers.find(
+      (specifier) => t3.isImportSpecifier(specifier) && t3.isIdentifier(specifier.imported) && specifier.imported.name === name
+    ), "hasImportSpecifier");
+    const hasDefaultImportSpecifier = /* @__PURE__ */ __name((declaration, name) => declaration.specifiers.find((specifier) => t3.isImportDefaultSpecifier(
+    specifier)), "hasDefaultImportSpecifier");
+    const importDeclaration = this._ast.program.body.find(
+      (node) => t3.isImportDeclaration(node) && node.source.value === fromImport
     );
+    if (typeof importSpecifier === "string") {
+      if (importDeclaration) {
+        if (!hasDefaultImportSpecifier(importDeclaration, importSpecifier)) {
+          importDeclaration.specifiers.push(
+            t3.importDefaultSpecifier(t3.identifier(importSpecifier))
+          );
+        }
+      } else {
+        this._ast.program.body.unshift(
+          t3.importDeclaration(
+            [t3.importDefaultSpecifier(t3.identifier(importSpecifier))],
+            t3.stringLiteral(fromImport)
+          )
+        );
+      }
+    } else if (importDeclaration) {
+      importSpecifier.forEach((specifier) => {
+        if (!hasImportSpecifier(importDeclaration, specifier)) {
+          importDeclaration.specifiers.push(getNewImportSpecifier(specifier));
+        }
+      });
+    } else {
+      this._ast.program.body.unshift(
+        t3.importDeclaration(
+          importSpecifier.map(
+            (specifier) => t3.importSpecifier(t3.identifier(specifier), t3.identifier(specifier))
+          ),
+          t3.stringLiteral(fromImport)
+        )
+      );
+    }
   }
-}, Ze = /* @__PURE__ */ p((s, e) => {
-  let i = pe(s);
-  return new G(i, s, e);
-}, "loadConfig"), et = /* @__PURE__ */ p((s) => tt(s).code, "formatConfig"), tt = /* @__PURE__ */ p((s, e = {}) => Ye.print(s._ast, e), "pri\
-ntConfig"), Ct = /* @__PURE__ */ p(async (s) => {
-  let e = (await Qe(s, "utf-8")).toString();
-  return Ze(e, s).parse();
-}, "readConfig"), Tt = /* @__PURE__ */ p(async (s, e) => {
-  let i = e || s.fileName;
-  if (!i)
+};
+var loadConfig = /* @__PURE__ */ __name((code, fileName) => {
+  const ast = babelParse2(code);
+  return new ConfigFile(ast, code, fileName);
+}, "loadConfig");
+var formatConfig = /* @__PURE__ */ __name((config) => {
+  return printConfig(config).code;
+}, "formatConfig");
+var printConfig = /* @__PURE__ */ __name((config, options = {}) => {
+  return recast2.print(config._ast, options);
+}, "printConfig");
+var readConfig = /* @__PURE__ */ __name(async (fileName) => {
+  const code = (await readFile2(fileName, "utf-8")).toString();
+  return loadConfig(code, fileName).parse();
+}, "readConfig");
+var writeConfig = /* @__PURE__ */ __name(async (config, fileName) => {
+  const fname = fileName || config.fileName;
+  if (!fname) {
     throw new Error("Please specify a fileName for writeConfig");
-  await He(i, et(s));
+  }
+  await writeFile2(fname, formatConfig(config));
 }, "writeConfig");
 
 // src/csf-tools/getStorySortParameter.ts
-var xe = A(N(), 1);
-import { babelParse as rt, generate as ge, types as y, traverse as it } from "@storybook/core/babel";
-var st = console, J = /* @__PURE__ */ p((s, e) => {
-  let i;
-  return s.properties.forEach((t) => {
-    y.isIdentifier(t.key) && t.key.name === e && (i = t.value);
-  }), i;
-}, "getValue"), K = /* @__PURE__ */ p((s) => {
-  let e = k(s);
-  if (y.isArrayExpression(e))
-    return e.elements.map((i) => K(i));
-  if (y.isObjectExpression(e))
-    return e.properties.reduce((i, t) => (y.isIdentifier(t.key) && (i[t.key.name] = K(t.value)), i), {});
-  if (y.isLiteral(e))
-    return e.value;
-  if (y.isIdentifier(e))
-    return v(e.name, !0);
-  throw new Error(`Unknown node type ${e.type}`);
-}, "parseValue"), v = /* @__PURE__ */ p((s, e) => {
-  let i = xe.dedent`
-    Unexpected '${s}'. Parameter 'options.storySort' should be defined inline e.g.:
+var import_ts_dedent3 = __toESM(require_dist(), 1);
+import { babelParse as babelParse3, generate as generate3, types as t4, traverse as traverse3 } from "@storybook/core/babel";
+var logger3 = console;
+var getValue = /* @__PURE__ */ __name((obj, key) => {
+  let value;
+  obj.properties.forEach((p) => {
+    if (t4.isIdentifier(p.key) && p.key.name === key) {
+      value = p.value;
+    }
+  });
+  return value;
+}, "getValue");
+var parseValue = /* @__PURE__ */ __name((value) => {
+  const expr = stripTSModifiers(value);
+  if (t4.isArrayExpression(expr)) {
+    return expr.elements.map((o) => {
+      return parseValue(o);
+    });
+  }
+  if (t4.isObjectExpression(expr)) {
+    return expr.properties.reduce((acc, p) => {
+      if (t4.isIdentifier(p.key)) {
+        acc[p.key.name] = parseValue(p.value);
+      }
+      return acc;
+    }, {});
+  }
+  if (t4.isLiteral(expr)) {
+    return expr.value;
+  }
+  if (t4.isIdentifier(expr)) {
+    return unsupported(expr.name, true);
+  }
+  throw new Error(`Unknown node type ${expr.type}`);
+}, "parseValue");
+var unsupported = /* @__PURE__ */ __name((unexpectedVar, isError) => {
+  const message = import_ts_dedent3.dedent`
+    Unexpected '${unexpectedVar}'. Parameter 'options.storySort' should be defined inline e.g.:
 
     export default {
       parameters: {
@@ -984,345 +1397,458 @@ var st = console, J = /* @__PURE__ */ p((s, e) => {
       },
     };
   `;
-  if (e)
-    throw new Error(i);
-  st.info(i);
-}, "unsupported"), k = /* @__PURE__ */ p((s) => y.isTSAsExpression(s) || y.isTSSatisfiesExpression(s) ? s.expression : s, "stripTSModifiers"),
-ye = /* @__PURE__ */ p((s) => {
-  let e = k(s);
-  if (y.isObjectExpression(e)) {
-    let i = J(e, "options");
-    if (i) {
-      if (y.isObjectExpression(i))
-        return J(i, "storySort");
-      v("options", !0);
+  if (isError) {
+    throw new Error(message);
+  } else {
+    logger3.info(message);
+  }
+}, "unsupported");
+var stripTSModifiers = /* @__PURE__ */ __name((expr) => t4.isTSAsExpression(expr) || t4.isTSSatisfiesExpression(expr) ? expr.expression : expr,
+"stripTSModifiers");
+var parseParameters = /* @__PURE__ */ __name((params) => {
+  const paramsObject = stripTSModifiers(params);
+  if (t4.isObjectExpression(paramsObject)) {
+    const options = getValue(paramsObject, "options");
+    if (options) {
+      if (t4.isObjectExpression(options)) {
+        return getValue(options, "storySort");
+      }
+      unsupported("options", true);
     }
   }
-}, "parseParameters"), nt = /* @__PURE__ */ p((s, e) => {
-  let i = k(s);
-  if (y.isObjectExpression(i)) {
-    let t = J(i, "parameters");
-    if (y.isIdentifier(t) && (t = O(t.name, e)), t)
-      return ye(t);
-  } else
-    v("default", !0);
-}, "parseDefault"), Lt = /* @__PURE__ */ p((s) => {
-  if (!s.includes("storySort"))
-    return;
-  let e, i = rt(s);
-  if (it(i, {
+  return void 0;
+}, "parseParameters");
+var parseDefault = /* @__PURE__ */ __name((defaultExpr, program) => {
+  const defaultObj = stripTSModifiers(defaultExpr);
+  if (t4.isObjectExpression(defaultObj)) {
+    let params = getValue(defaultObj, "parameters");
+    if (t4.isIdentifier(params)) {
+      params = findVarInitialization(params.name, program);
+    }
+    if (params) {
+      return parseParameters(params);
+    }
+  } else {
+    unsupported("default", true);
+  }
+  return void 0;
+}, "parseDefault");
+var getStorySortParameter = /* @__PURE__ */ __name((previewCode) => {
+  if (!previewCode.includes("storySort")) {
+    return void 0;
+  }
+  let storySort;
+  const ast = babelParse3(previewCode);
+  traverse3(ast, {
     ExportNamedDeclaration: {
-      enter({ node: t }) {
-        y.isVariableDeclaration(t.declaration) ? t.declaration.declarations.forEach((r) => {
-          if (y.isVariableDeclarator(r) && y.isIdentifier(r.id)) {
-            let { name: a } = r.id;
-            if (a === "parameters" && r.init) {
-              let n = k(r.init);
-              e = ye(n);
+      enter({ node }) {
+        if (t4.isVariableDeclaration(node.declaration)) {
+          node.declaration.declarations.forEach((decl) => {
+            if (t4.isVariableDeclarator(decl) && t4.isIdentifier(decl.id)) {
+              const { name: exportName } = decl.id;
+              if (exportName === "parameters" && decl.init) {
+                const paramsObject = stripTSModifiers(decl.init);
+                storySort = parseParameters(paramsObject);
+              }
             }
-          }
-        }) : t.specifiers.forEach((r) => {
-          y.isIdentifier(r.exported) && r.exported.name === "parameters" && v("parameters", !1);
-        });
+          });
+        } else {
+          node.specifiers.forEach((spec) => {
+            if (t4.isIdentifier(spec.exported) && spec.exported.name === "parameters") {
+              unsupported("parameters", false);
+            }
+          });
+        }
       }
     },
     ExportDefaultDeclaration: {
-      enter({ node: t }) {
-        let r = t.declaration;
-        y.isIdentifier(r) && (r = O(r.name, i.program)), r = k(r), y.isObjectExpression(r) ? e = nt(r, i.program) : v("default", !1);
+      enter({ node }) {
+        let defaultObj = node.declaration;
+        if (t4.isIdentifier(defaultObj)) {
+          defaultObj = findVarInitialization(defaultObj.name, ast.program);
+        }
+        defaultObj = stripTSModifiers(defaultObj);
+        if (t4.isObjectExpression(defaultObj)) {
+          storySort = parseDefault(defaultObj, ast.program);
+        } else {
+          unsupported("default", false);
+        }
       }
     }
-  }), !!e) {
-    if (y.isArrowFunctionExpression(e)) {
-      let { code: t } = ge(e, {});
-      return (0, eval)(t);
-    }
-    if (y.isFunctionExpression(e)) {
-      let { code: t } = ge(e, {}), r = e.id?.name, a = `(a, b) => {
-      ${t};
-      return ${r}(a, b)
+  });
+  if (!storySort) {
+    return void 0;
+  }
+  if (t4.isArrowFunctionExpression(storySort)) {
+    const { code: sortCode } = generate3(storySort, {});
+    return (0, eval)(sortCode);
+  }
+  if (t4.isFunctionExpression(storySort)) {
+    const { code: sortCode } = generate3(storySort, {});
+    const functionName = storySort.id?.name;
+    const wrapper = `(a, b) => {
+      ${sortCode};
+      return ${functionName}(a, b)
     }`;
-      return (0, eval)(a);
-    }
-    return y.isLiteral(e) || y.isArrayExpression(e) || y.isObjectExpression(e) ? K(e) : v("storySort", !0);
+    return (0, eval)(wrapper);
   }
+  if (t4.isLiteral(storySort) || t4.isArrayExpression(storySort) || t4.isObjectExpression(storySort)) {
+    return parseValue(storySort);
+  }
+  return unsupported("storySort", true);
 }, "getStorySortParameter");
 
 // src/csf-tools/enrichCsf.ts
-import { generate as ot, types as m } from "@storybook/core/babel";
-var at = /* @__PURE__ */ p((s, e, i, t) => {
-  let r = e.getStoryExport(i), a = !t?.disableSource && ct(r), n = !t?.disableDescription && Ee(e._storyStatements[i]), l = [], u = m.memberExpression(
-  m.identifier(i), m.identifier("parameters"));
-  l.push(m.spreadElement(u));
-  let d = m.optionalMemberExpression(
-    u,
-    m.identifier("docs"),
-    !1,
-    !0
-  ), x = [];
-  if (a) {
-    let g = m.optionalMemberExpression(
-      d,
-      m.identifier("source"),
-      !1,
-      !0
+import { generate as generate4, types as t5 } from "@storybook/core/babel";
+var enrichCsfStory = /* @__PURE__ */ __name((csf, csfSource, key, options) => {
+  const storyExport = csfSource.getStoryExport(key);
+  const source = !options?.disableSource && extractSource(storyExport);
+  const description = !options?.disableDescription && extractDescription(csfSource._storyStatements[key]);
+  const parameters = [];
+  const originalParameters = t5.memberExpression(t5.identifier(key), t5.identifier("parameters"));
+  parameters.push(t5.spreadElement(originalParameters));
+  const optionalDocs = t5.optionalMemberExpression(
+    originalParameters,
+    t5.identifier("docs"),
+    false,
+    true
+  );
+  const extraDocsParameters = [];
+  if (source) {
+    const optionalSource = t5.optionalMemberExpression(
+      optionalDocs,
+      t5.identifier("source"),
+      false,
+      true
     );
-    x.push(
-      m.objectProperty(
-        m.identifier("source"),
-        m.objectExpression([
-          m.objectProperty(m.identifier("originalSource"), m.stringLiteral(a)),
-          m.spreadElement(g)
+    extraDocsParameters.push(
+      t5.objectProperty(
+        t5.identifier("source"),
+        t5.objectExpression([
+          t5.objectProperty(t5.identifier("originalSource"), t5.stringLiteral(source)),
+          t5.spreadElement(optionalSource)
         ])
       )
     );
   }
-  if (n) {
-    let g = m.optionalMemberExpression(
-      d,
-      m.identifier("description"),
-      !1,
-      !0
+  if (description) {
+    const optionalDescription = t5.optionalMemberExpression(
+      optionalDocs,
+      t5.identifier("description"),
+      false,
+      true
     );
-    x.push(
-      m.objectProperty(
-        m.identifier("description"),
-        m.objectExpression([
-          m.objectProperty(m.identifier("story"), m.stringLiteral(n)),
-          m.spreadElement(g)
+    extraDocsParameters.push(
+      t5.objectProperty(
+        t5.identifier("description"),
+        t5.objectExpression([
+          t5.objectProperty(t5.identifier("story"), t5.stringLiteral(description)),
+          t5.spreadElement(optionalDescription)
         ])
       )
     );
   }
-  if (x.length > 0) {
-    l.push(
-      m.objectProperty(
-        m.identifier("docs"),
-        m.objectExpression([m.spreadElement(d), ...x])
+  if (extraDocsParameters.length > 0) {
+    parameters.push(
+      t5.objectProperty(
+        t5.identifier("docs"),
+        t5.objectExpression([t5.spreadElement(optionalDocs), ...extraDocsParameters])
       )
     );
-    let g = m.expressionStatement(
-      m.assignmentExpression("=", u, m.objectExpression(l))
+    const addParameter = t5.expressionStatement(
+      t5.assignmentExpression("=", originalParameters, t5.objectExpression(parameters))
     );
-    s._ast.program.body.push(g);
+    csf._ast.program.body.push(addParameter);
   }
-}, "enrichCsfStory"), be = /* @__PURE__ */ p((s, e, i) => {
-  if (!e.length) {
-    s.properties.find(
-      (u) => m.isObjectProperty(u) && m.isIdentifier(u.key) && u.key.name === "component"
-    ) || s.properties.unshift(i);
+}, "enrichCsfStory");
+var addComponentDescription = /* @__PURE__ */ __name((node, path, value) => {
+  if (!path.length) {
+    const hasExistingComponent = node.properties.find(
+      (p) => t5.isObjectProperty(p) && t5.isIdentifier(p.key) && p.key.name === "component"
+    );
+    if (!hasExistingComponent) {
+      node.properties.unshift(value);
+    }
     return;
   }
-  let [t, ...r] = e, a = s.properties.find(
-    (l) => m.isObjectProperty(l) && m.isIdentifier(l.key) && l.key.name === t && m.isObjectExpression(l.value)
-  ), n;
-  a ? n = a.value : (n = m.objectExpression([]), s.properties.push(m.objectProperty(m.identifier(t), n))), be(n, r, i);
-}, "addComponentDescription"), lt = /* @__PURE__ */ p((s, e, i) => {
-  let t = !i?.disableDescription && Ee(e._metaStatement);
-  if (t) {
-    let r = s._metaNode;
-    r && m.isObjectExpression(r) && be(
-      r,
-      ["parameters", "docs", "description"],
-      m.objectProperty(m.identifier("component"), m.stringLiteral(t))
-    );
+  const [first, ...rest] = path;
+  const existing = node.properties.find(
+    (p) => t5.isObjectProperty(p) && t5.isIdentifier(p.key) && p.key.name === first && t5.isObjectExpression(p.value)
+  );
+  let subNode;
+  if (existing) {
+    subNode = existing.value;
+  } else {
+    subNode = t5.objectExpression([]);
+    node.properties.push(t5.objectProperty(t5.identifier(first), subNode));
+  }
+  addComponentDescription(subNode, rest, value);
+}, "addComponentDescription");
+var enrichCsfMeta = /* @__PURE__ */ __name((csf, csfSource, options) => {
+  const description = !options?.disableDescription && extractDescription(csfSource._metaStatement);
+  if (description) {
+    const metaNode = csf._metaNode;
+    if (metaNode && t5.isObjectExpression(metaNode)) {
+      addComponentDescription(
+        metaNode,
+        ["parameters", "docs", "description"],
+        t5.objectProperty(t5.identifier("component"), t5.stringLiteral(description))
+      );
+    }
   }
-}, "enrichCsfMeta"), qt = /* @__PURE__ */ p((s, e, i) => {
-  lt(s, e, i), Object.keys(s._storyExports).forEach((t) => {
-    at(s, e, t, i);
+}, "enrichCsfMeta");
+var enrichCsf = /* @__PURE__ */ __name((csf, csfSource, options) => {
+  enrichCsfMeta(csf, csfSource, options);
+  Object.keys(csf._storyExports).forEach((key) => {
+    enrichCsfStory(csf, csfSource, key, options);
   });
-}, "enrichCsf"), ct = /* @__PURE__ */ p((s) => {
-  let e = m.isVariableDeclarator(s) ? s.init : s, { code: i } = ot(e, {});
-  return i;
-}, "extractSource"), Ee = /* @__PURE__ */ p((s) => s?.leadingComments ? s.leadingComments.map((i) => i.type === "CommentLine" || !i.value.startsWith(
-"*") ? null : i.value.split(`
-`).map((t) => t.replace(/^(\s+)?(\*+)?(\s)?/, "")).join(`
-`).trim()).filter(Boolean).join(`
-`) : "", "extractDescription");
+}, "enrichCsf");
+var extractSource = /* @__PURE__ */ __name((node) => {
+  const src = t5.isVariableDeclarator(node) ? node.init : node;
+  const { code } = generate4(src, {});
+  return code;
+}, "extractSource");
+var extractDescription = /* @__PURE__ */ __name((node) => {
+  if (!node?.leadingComments) {
+    return "";
+  }
+  const comments = node.leadingComments.map((comment) => {
+    if (comment.type === "CommentLine" || !comment.value.startsWith("*")) {
+      return null;
+    }
+    return comment.value.split("\n").map((line) => line.replace(/^(\s+)?(\*+)?(\s)?/, "")).join("\n").trim();
+  }).filter(Boolean);
+  return comments.join("\n");
+}, "extractDescription");
 
 // src/csf-tools/index.ts
-import { babelParse as ir } from "@storybook/core/babel";
+import { babelParse as babelParse4 } from "@storybook/core/babel";
 
 // src/csf-tools/vitest-plugin/transformer.ts
-var X = A(N(), 1);
-import { types as f } from "@storybook/core/babel";
-import { getStoryTitle as pt } from "@storybook/core/common";
-import { combineTags as ft } from "@storybook/csf";
-var he = console, dt = /* @__PURE__ */ p((s, e) => {
-  let i = e?.include.length === 0 || e?.include.some((r) => s.includes(r)), t = e?.exclude.every((r) => !s.includes(r));
-  return i && t;
+var import_ts_dedent4 = __toESM(require_dist(), 1);
+import { types as t6 } from "@storybook/core/babel";
+import { getStoryTitle } from "@storybook/core/common";
+import { combineTags } from "@storybook/csf";
+var logger4 = console;
+var isValidTest = /* @__PURE__ */ __name((storyTags, tagsFilter) => {
+  const isIncluded = tagsFilter?.include.length === 0 || tagsFilter?.include.some((tag) => storyTags.includes(tag));
+  const isNotExcluded = tagsFilter?.exclude.every((tag) => !storyTags.includes(tag));
+  return isIncluded && isNotExcluded;
 }, "isValidTest");
-async function ut({
-  code: s,
-  fileName: e,
-  configDir: i,
-  stories: t,
-  tagsFilter: r,
-  previewLevelTags: a = []
+async function vitestTransform({
+  code,
+  fileName,
+  configDir,
+  stories,
+  tagsFilter,
+  previewLevelTags = []
 }) {
-  if (!/\.stor(y|ies)\./.test(e))
-    return s;
-  let l = q(s, {
-    fileName: e,
-    transformInlineMeta: !0,
-    makeTitle: /* @__PURE__ */ p((E) => {
-      let j = pt({
-        storyFilePath: e,
-        configDir: i,
-        stories: t,
-        userTitle: E
+  const isStoryFile = /\.stor(y|ies)\./.test(fileName);
+  if (!isStoryFile) {
+    return code;
+  }
+  const parsed = loadCsf(code, {
+    fileName,
+    transformInlineMeta: true,
+    makeTitle: /* @__PURE__ */ __name((title) => {
+      const result = getStoryTitle({
+        storyFilePath: fileName,
+        configDir,
+        stories,
+        userTitle: title
       }) || "unknown";
-      return j === "unknown" && he.warn(
-        X.dedent`
-            [Storybook]: Could not calculate story title for "${e}".
-            Please make sure that this file matches the globs included in the "stories" field in your Storybook configuration at "${i}".
+      if (result === "unknown") {
+        logger4.warn(
+          import_ts_dedent4.dedent`
+            [Storybook]: Could not calculate story title for "${fileName}".
+            Please make sure that this file matches the globs included in the "stories" field in your Storybook configuration at "${configDir}".
           `
-      ), j;
+        );
+      }
+      return result;
     }, "makeTitle")
-  }).parse(), u = l._ast, d = l._metaVariableName, x = l._metaNode, g = x.properties.find(
-    (E) => f.isObjectProperty(E) && f.isIdentifier(E.key) && E.key.name === "title"
-  ), b = f.stringLiteral(l._meta?.title || "unknown");
-  if (g ? f.isObjectProperty(g) && (g.value = b) : x.properties.push(f.objectProperty(f.identifier("title"), b)), !x || !l._meta)
+  }).parse();
+  const ast = parsed._ast;
+  const metaExportName = parsed._metaVariableName;
+  const metaNode = parsed._metaNode;
+  const metaTitleProperty = metaNode.properties.find(
+    (prop) => t6.isObjectProperty(prop) && t6.isIdentifier(prop.key) && prop.key.name === "title"
+  );
+  const metaTitle = t6.stringLiteral(parsed._meta?.title || "unknown");
+  if (!metaTitleProperty) {
+    metaNode.properties.push(t6.objectProperty(t6.identifier("title"), metaTitle));
+  } else if (t6.isObjectProperty(metaTitleProperty)) {
+    metaTitleProperty.value = metaTitle;
+  }
+  if (!metaNode || !parsed._meta) {
     throw new Error(
-      `The Storybook vitest plugin could not detect the meta (default export) object in the story file. 
-
-Please make sure you have a default export with the meta object. If you are using a different export format that is not supported, please fi\
-le an issue with details about your use case.`
+      "The Storybook vitest plugin could not detect the meta (default export) object in the story file. \n\nPlease make sure you have a defaul\
+t export with the meta object. If you are using a different export format that is not supported, please file an issue with details about you\
+r use case."
     );
-  let h = {};
-  Object.keys(l._stories).map((E) => {
-    let j = ft(
+  }
+  const validStories = {};
+  Object.keys(parsed._stories).map((key) => {
+    const finalTags = combineTags(
       "test",
       "dev",
-      ...a,
-      ...l.meta?.tags || [],
-      ...l._stories[E].tags || []
+      ...previewLevelTags,
+      ...parsed.meta?.tags || [],
+      ...parsed._stories[key].tags || []
     );
-    dt(j, r) && (h[E] = l._storyStatements[E]);
+    if (isValidTest(finalTags, tagsFilter)) {
+      validStories[key] = parsed._storyStatements[key];
+    }
   });
-  let _ = l._file.path.scope.generateUidIdentifier("test"), Q = l._file.path.scope.generateUidIdentifier("describe");
-  if (Object.keys(h).length === 0) {
-    let E = f.expressionStatement(
-      f.callExpression(f.memberExpression(Q, f.identifier("skip")), [
-        f.stringLiteral("No valid tests found")
+  const vitestTestId = parsed._file.path.scope.generateUidIdentifier("test");
+  const vitestDescribeId = parsed._file.path.scope.generateUidIdentifier("describe");
+  if (Object.keys(validStories).length === 0) {
+    const describeSkipBlock = t6.expressionStatement(
+      t6.callExpression(t6.memberExpression(vitestDescribeId, t6.identifier("skip")), [
+        t6.stringLiteral("No valid tests found")
       ])
     );
-    u.program.body.push(E);
-    let j = [
-      f.importDeclaration(
+    ast.program.body.push(describeSkipBlock);
+    const imports = [
+      t6.importDeclaration(
         [
-          f.importSpecifier(_, f.identifier("test")),
-          f.importSpecifier(Q, f.identifier("describe"))
+          t6.importSpecifier(vitestTestId, t6.identifier("test")),
+          t6.importSpecifier(vitestDescribeId, t6.identifier("describe"))
         ],
-        f.stringLiteral("vitest")
+        t6.stringLiteral("vitest")
       )
     ];
-    u.program.body.unshift(...j);
+    ast.program.body.unshift(...imports);
   } else {
-    let H = function() {
-      let S = l._file.path.scope.generateUidIdentifier("isRunningFromThisFile"), P = f.memberExpression(
-        f.callExpression(f.memberExpression(E, f.identifier("getState")), []),
-        f.identifier("testPath")
-      ), V = f.memberExpression(
-        f.memberExpression(f.identifier("globalThis"), f.identifier("__vitest_worker__")),
-        f.identifier("filepath")
-      ), Ie = f.logicalExpression(
+    let getTestGuardDeclaration2 = function() {
+      const isRunningFromThisFileId2 = parsed._file.path.scope.generateUidIdentifier("isRunningFromThisFile");
+      const testPathProperty = t6.memberExpression(
+        t6.callExpression(t6.memberExpression(vitestExpectId, t6.identifier("getState")), []),
+        t6.identifier("testPath")
+      );
+      const filePathProperty = t6.memberExpression(
+        t6.memberExpression(t6.identifier("globalThis"), t6.identifier("__vitest_worker__")),
+        t6.identifier("filepath")
+      );
+      const nullishCoalescingExpression = t6.logicalExpression(
         "??",
         // TODO: switch order of testPathProperty and filePathProperty when the bug is fixed
         // https://github.com/vitest-dev/vitest/issues/6367 (or probably just use testPathProperty)
-        V,
-        P
-      ), Ne = f.callExpression(
-        f.memberExpression(
-          f.memberExpression(
-            f.memberExpression(f.identifier("import"), f.identifier("meta")),
-            f.identifier("url")
+        filePathProperty,
+        testPathProperty
+      );
+      const includesCall = t6.callExpression(
+        t6.memberExpression(
+          t6.memberExpression(
+            t6.memberExpression(t6.identifier("import"), t6.identifier("meta")),
+            t6.identifier("url")
           ),
-          f.identifier("includes")
+          t6.identifier("includes")
         ),
-        [Ie]
+        [nullishCoalescingExpression]
       );
-      return { isRunningFromThisFileDeclaration: f.variableDeclaration("const", [
-        f.variableDeclarator(S, Ne)
-      ]), isRunningFromThisFileId: S };
+      const isRunningFromThisFileDeclaration2 = t6.variableDeclaration("const", [
+        t6.variableDeclarator(isRunningFromThisFileId2, includesCall)
+      ]);
+      return { isRunningFromThisFileDeclaration: isRunningFromThisFileDeclaration2, isRunningFromThisFileId: isRunningFromThisFileId2 };
     };
-    var mt = H;
-    p(H, "getTestGuardDeclaration");
-    let E = l._file.path.scope.generateUidIdentifier("expect"), j = l._file.path.scope.generateUidIdentifier("testStory"), _e = f.identifier(
-    JSON.stringify(r.skip)), { isRunningFromThisFileDeclaration: Se, isRunningFromThisFileId: je } = H();
-    u.program.body.push(Se);
-    let Oe = /* @__PURE__ */ p(({
-      exportName: S,
-      node: P
+    var getTestGuardDeclaration = getTestGuardDeclaration2;
+    __name(getTestGuardDeclaration2, "getTestGuardDeclaration");
+    const vitestExpectId = parsed._file.path.scope.generateUidIdentifier("expect");
+    const testStoryId = parsed._file.path.scope.generateUidIdentifier("testStory");
+    const skipTagsId = t6.identifier(JSON.stringify(tagsFilter.skip));
+    const { isRunningFromThisFileDeclaration, isRunningFromThisFileId } = getTestGuardDeclaration2();
+    ast.program.body.push(isRunningFromThisFileDeclaration);
+    const getTestStatementForStory = /* @__PURE__ */ __name(({
+      exportName,
+      node
     }) => {
-      let V = f.expressionStatement(
-        f.callExpression(_, [
-          f.stringLiteral(S),
-          f.callExpression(j, [
-            f.stringLiteral(S),
-            f.identifier(S),
-            f.identifier(d),
-            _e
+      const testStoryCall = t6.expressionStatement(
+        t6.callExpression(vitestTestId, [
+          t6.stringLiteral(exportName),
+          t6.callExpression(testStoryId, [
+            t6.stringLiteral(exportName),
+            t6.identifier(exportName),
+            t6.identifier(metaExportName),
+            skipTagsId
           ])
         ])
       );
-      return V.loc = P.loc, V;
-    }, "getTestStatementForStory"), Pe = Object.entries(h).map(([S, P]) => {
-      if (P === null) {
-        he.warn(
-          X.dedent`
-            [Storybook]: Could not transform "${S}" story into test at "${e}".
+      testStoryCall.loc = node.loc;
+      return testStoryCall;
+    }, "getTestStatementForStory");
+    const storyTestStatements = Object.entries(validStories).map(([exportName, node]) => {
+      if (node === null) {
+        logger4.warn(
+          import_ts_dedent4.dedent`
+            [Storybook]: Could not transform "${exportName}" story into test at "${fileName}".
             Please make sure to define stories in the same file and not re-export stories coming from other files".
           `
         );
         return;
       }
-      return Oe({
-        exportName: S,
-        node: P
+      return getTestStatementForStory({
+        exportName,
+        node
       });
-    }).filter((S) => !!S), De = f.ifStatement(je, f.blockStatement(Pe));
-    u.program.body.push(De);
-    let ve = [
-      f.importDeclaration(
+    }).filter((st) => !!st);
+    const testBlock = t6.ifStatement(isRunningFromThisFileId, t6.blockStatement(storyTestStatements));
+    const describeBlock = t6.expressionStatement(
+      t6.callExpression(
+        vitestDescribeId,
+        [
+          t6.stringLiteral("foo"),
+          t6.arrowFunctionExpression(
+            [],
+            t6.blockStatement([
+              testBlock
+            ])
+          )
+        ]
+      )
+    );
+    ast.program.body.push(describeBlock);
+    const imports = [
+      t6.importDeclaration(
         [
-          f.importSpecifier(_, f.identifier("test")),
-          f.importSpecifier(E, f.identifier("expect"))
+          t6.importSpecifier(vitestDescribeId, t6.identifier("describe")),
+          t6.importSpecifier(vitestTestId, t6.identifier("test")),
+          t6.importSpecifier(vitestExpectId, t6.identifier("expect"))
         ],
-        f.stringLiteral("vitest")
+        t6.stringLiteral("vitest")
       ),
-      f.importDeclaration(
-        [f.importSpecifier(j, f.identifier("testStory"))],
-        f.stringLiteral("@storybook/experimental-addon-test/internal/test-utils")
+      t6.importDeclaration(
+        [t6.importSpecifier(testStoryId, t6.identifier("testStory"))],
+        t6.stringLiteral("@storybook/experimental-addon-test/internal/test-utils")
       )
     ];
-    u.program.body.unshift(...ve);
+    ast.program.body.unshift(...imports);
   }
-  return ae(l, { sourceMaps: !0, sourceFileName: e }, s);
+  return formatCsf(parsed, { sourceMaps: true, sourceFileName: fileName }, code);
 }
-p(ut, "vitestTransform");
+__name(vitestTransform, "vitestTransform");
 export {
-  G as ConfigFile,
-  U as CsfFile,
-  R as NoMetaError,
-  ir as babelParse,
-  Ke as babelParseFile,
-  qt as enrichCsf,
-  lt as enrichCsfMeta,
-  at as enrichCsfStory,
-  Ee as extractDescription,
-  ct as extractSource,
-  et as formatConfig,
-  ae as formatCsf,
-  Lt as getStorySortParameter,
-  We as isModuleMock,
-  Ze as loadConfig,
-  q as loadCsf,
-  tt as printConfig,
-  Xe as printCsf,
-  Ct as readConfig,
-  Dt as readCsf,
-  ut as vitestTransform,
-  Tt as writeConfig,
-  vt as writeCsf
+  ConfigFile,
+  CsfFile,
+  NoMetaError,
+  babelParse4 as babelParse,
+  babelParseFile,
+  enrichCsf,
+  enrichCsfMeta,
+  enrichCsfStory,
+  extractDescription,
+  extractSource,
+  formatConfig,
+  formatCsf,
+  getStorySortParameter,
+  isModuleMock,
+  loadConfig,
+  loadCsf,
+  printConfig,
+  printCsf,
+  readConfig,
+  readCsf,
+  vitestTransform,
+  writeConfig,
+  writeCsf
 };
